<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">The monumental impact of C</span></p><p class="para4"><span class="span3">By Matthew Broberg</span></p><p class="para4"><span class="span3">C is the original general-purpose programming language. The Season 3 finale of the </span><a href="https://www.redhat.com/en/command-line-heroes"><span class="span4">Command Line Heroes</span></a><span class="span3"> podcast explores C&apos;s origin story in a way that showcases the longevity and power of its design. It&apos;s a perfect synthesis of all the languages discussed throughout the podcast&apos;s third season and this </span><a href="https://opensource.com/tags/command-line-heroes-podcast"><span class="span4">series of articles</span></a><span class="span3">.</span></p><p class="para4"><img alt="OEBPS/images/image0017.jpg" class="frame6" src="../images/image0017.jpg"/><span class="span3"> </span> </p><p class="para4"><span class="span3">C is such a fundamental language that many of us forget how much it has changed. Technically a &quot;high-level language,&quot; in the sense that it requires a compiler to be runnable, it&apos;s as close to assembly language as people like to get these days (outside of specialized, low-memory environments). It&apos;s also considered to be the language that made nearly all languages that came after it possible.</span></p><p class="para5"><span class="span5">The path to C began with failure</span></p><p class="para4"><span class="span3">While the myth persists that all great inventions come from highly competitive garage dwellers, C&apos;s story is more fit for the Renaissance period.</span></p><p class="para4"><span class="span3">In the 1960s, Bell Labs in suburban New Jersey was one of the most innovative places of its time. Jon Gertner, author of </span><a href="https://en.wikipedia.org/wiki/The_Idea_Factory"><span class="span17">The idea factory</span></a><span class="span3">, describes the culture of the time marked by optimism and the excitement to solve tough problems. Instead of monetization pressures with tight timelines, Bell Labs offered seemingly endless funding for wild ideas. It had a research and development ethos that aligns well with today&apos;s </span><a href="https://opensource.com/open-organization/18/12/what-is-open-leadership"><span class="span4">open leadership principles</span></a><span class="span3">. The results were significant and prove that brilliance can come without the promise of VC funding or an IPO.</span></p><p class="para4"><span class="span3">The challenge back then was terminal sharing: finding a way for lots of people to access the (very limited number of) available computers. Before there was a scalable answer for that, and long before we had </span><a href="https://opensource.com/19/9/command-line-heroes-bash"><span class="span4">a shell like Bash</span></a><span class="span3">, there was the Multics project. It was a hypothetical operating system where hundreds or even thousands of developers could share time on the same system. This was a dream of John McCarty, creator of Lisp and the term artificial intelligence (AI), as I </span><a href="https://opensource.com/article/19/9/command-line-heroes-lisp"><span class="span4">recently explored</span></a><span class="span3">.</span></p><p class="para4"><span class="span3">Joy Lisi Ranken, author of </span><a href="https://www.hup.harvard.edu/catalog.php?isbn=9780674970977"><span class="span17">A people&apos;s history of computing in the United States</span></a><span class="span3">, describes what happened next. There was a lot of public interest in driving forward with Multics&apos; vision of more universally available timesharing. Academics, scientists, educators, and some in the broader public were looking forward to this computer-powered future. Many advocated for computing as a public utility, akin to electricity, and the push toward timesharing was a global movement.</span></p><p class="para4"><span class="span3">Up to that point, high-end mainframes topped out at 40-50 terminals per system. The change of scale was ambitious and eventually failed, as Warren Toomey writes in </span><a href="https://spectrum.ieee.org/tech-history/cyberspace/the-strange-birth-and-long-life-of-unix"><span class="span4">IEEE Spectrum</span></a><span class="span3">:</span></p><p class="para10"><span class="span12">&quot;Over five years, AT&amp;T invested millions in the Multics project, purchasing a GE-645 mainframe computer and dedicating to the effort many of the top researchers at the company&apos;s renowned Bell Telephone Laboratories—including Thompson and Ritchie, Joseph F. Ossanna, Stuart Feldman, M. Douglas McIlroy, and the late Robert Morris. But the new system was too ambitious, and it fell troublingly behind schedule. In the end, AT&amp;T&apos;s corporate leaders decided to pull the plug.&quot;</span></p><p class="para4"><span class="span3">Bell Labs pulled out of the Multics program in 1969. Multics wasn&apos;t going to happen.</span></p><p class="para5"><span class="span5">The fellowship of the C</span></p><p class="para4"><span class="span3">Funding wrapped up, and the powerful GE645 mainframe was assigned to other tasks inside Bell Labs. But that didn&apos;t discourage everyone.</span></p><p class="para4"><span class="span3">Among the last holdouts from the Multics project were four men who felt passionately tied to the project: Ken Thompson, Dennis Ritchie, Doug McIlroy, and J.F. Ossanna. These four diehards continued to muse and scribble ideas on paper. Thompson and Ritchie developed a game called Space Travel for the PDP-7 minicomputer. While they were working on that, Thompson started implementing all those crazy hand-written ideas about filesystems they&apos;d developed among the wreckage of Multics.</span></p><p class="para4"><span class="span3">That&apos;s worth emphasizing: Some of the original filesystem specifications were written by hand and then programmed on what was effectively a toy compared to the systems they were using to build Multics. </span><a href="https://en.wikipedia.org/wiki/Ken_Thompson"><span class="span4">Wikipedia&apos;s Ken Thompson page</span></a><span class="span3"> dives deeper into what came next:</span></p><p class="para10"><span class="span3">&quot;While writing Multics, Thompson created the Bon programming language. He also created a video game called </span><a href="https://en.wikipedia.org/wiki/Space_Travel_(video_game)"><span class="span4">Space Travel</span></a><span class="span3">. Later, Bell Labs withdrew from the MULTICS project. In order to go on playing the game, Thompson found an old </span><a href="https://en.wikipedia.org/wiki/PDP-7"><span class="span4">PDP-7</span></a><span class="span3"> machine and rewrote Space Travel on it. Eventually, the tools developed by Thompson became the </span><a href="https://en.wikipedia.org/wiki/Unix"><span class="span4">Unix</span></a><span class="span3"> </span><a href="https://en.wikipedia.org/wiki/Operating_system"><span class="span4">operating system</span></a><span class="span3">: Working on a PDP-7, a team of Bell Labs researchers led by Thompson and Ritchie, and including Rudd Canaday, developed a </span><a href="https://en.wikipedia.org/wiki/File_system#Aspects_of_file_systems"><span class="span4">hierarchical file system</span></a><span class="span3">, the concepts of </span><a href="https://en.wikipedia.org/wiki/Process_(computing)"><span class="span4">computer processes</span></a><span class="span3"> and </span><a href="https://en.wikipedia.org/wiki/Device_file"><span class="span4">device files</span></a><span class="span3">, a </span><a href="https://en.wikipedia.org/wiki/Command-line_interface#Command-line_interpreter"><span class="span4">command-line interpreter</span></a><span class="span3">, </span><a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)"><span class="span4">pipes</span></a><span class="span3"> for easy inter-process communication, and some small utility programs. In 1970, </span><a href="https://en.wikipedia.org/wiki/Brian_Kernighan"><span class="span4">Brian Kernighan</span></a><span class="span3"> suggested the name &apos;Unix,&apos; in a pun on the name &apos;Multics.&apos; After initial work on Unix, Thompson decided that Unix needed a system programming language and created </span><a href="https://en.wikipedia.org/wiki/B_(programming_language)"><span class="span4">B</span></a><span class="span3">, a precursor to Ritchie&apos;s </span><a href="https://en.wikipedia.org/wiki/C_(programming_language)"><span class="span4">C</span></a><span class="span3">.&quot;</span></p><p class="para4"><span class="span3">As Walter Toomey documented in the IEEE Spectrum article mentioned above, Unix showed promise in a way the Multics project never materialized. After winning over the team and doing a lot more programming, the pathway to Unix was paved.</span></p><p class="para5"><span class="span5">Getting from B to C in Unix</span></p><p class="para4"><span class="span3">Thompson quickly created a Unix language he called B. B inherited much from its predecessor BCPL, but it wasn&apos;t enough of a breakaway from older languages. B didn&apos;t know data types, for starters. It&apos;s considered a typeless language, which meant its &quot;Hello World&quot; program looked like this:</span></p><p class="para6"><span class="span6">main( ) {</span></p><p class="para6"><span class="span6">extrn a, b, c;</span></p><p class="para6"><span class="span6">putchar(a); putchar(b); putchar(c); putchar(&apos;!*n&apos;);</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">a &apos;hell&apos;;</span></p><p class="para6"><span class="span6">b &apos;o, w&apos;;</span></p><p class="para7"><span class="span6">c &apos;orld&apos;;</span></p><p class="para4"><span class="span3">Even if you&apos;re not a programmer, it&apos;s clear that carving up strings four characters at a time would be limiting. It&apos;s also worth noting that this text is considered the original &quot;Hello World&quot; from Brian Kernighan&apos;s 1972 book, </span><a href="https://www.bell-labs.com/usr/dmr/www/btut.pdf"><span class="span17">A tutorial introduction to the language B</span></a><span class="span3"> (although that claim is not definitive).</span></p><p class="para4"><span class="span3">Typelessness aside, B&apos;s assembly-language counterparts were still yielding programs faster than was possible using the B compiler&apos;s threaded-code technique. So, from 1971 to 1973, Ritchie modified B. He added a &quot;character type&quot; and built a new compiler so that it didn&apos;t have to use threaded code anymore. After two years of work, B had become C.</span></p><p class="para5"><span class="span5">The right abstraction at the right time</span></p><p class="para4"><span class="span3">C&apos;s use of types and ease of compiling down to efficient assembly code made it the perfect language for the rise of minicomputers, which speak in bytecode. B was eventually overtaken by C. Once C became the language of Unix, it became the de facto standard across the budding computer industry. Unix was </span><span class="span9">the</span><span class="span3"> sharing platform of the pre-internet days. The more people wrote C, the better it got, and the more it was adopted. It eventually became an open standard itself. According to the </span><a href="http://cs-fundamentals.com/c-programming/history-of-c-programming-language.php"><span class="span4">Brief history of C programming language</span></a><span class="span3">:</span></p><p class="para10"><span class="span3">&quot;For many years, the de facto standard for C was the version supplied with the Unix operating system. In the summer of 1983 a committee was established to create an ANSI (American National Standards Institute) standard that would define the C language. The standardization process took six years (much longer than anyone reasonably expected).&quot;</span></p><p class="para4"><span class="span3">How influential is C today? A </span><a href="https://www.toptal.com/c/after-all-these-years-the-world-is-still-powered-by-c-programming"><span class="span4">quick review</span></a><span class="span3"> reveals:</span></p><p class="para8"><span class="span3">Parts of all major operating systems are written in C, including macOS, Windows, Linux, and Android. </span></p><p class="para8"><span class="span3">The world&apos;s most prolific databases, including DB2, MySQL, MS SQL, and PostgreSQL, are written in C. </span></p><p class="para4"><span class="span3">Many programming-language specifics begun in C, including Python, Go, Perl&apos;s core interpreter, and the R statistical language. </span></p><p class="para4"><span class="span3">Decades after they started as scrappy outsiders, Thompson and Ritchie are praised as titans of the programming world. They shared 1983&apos;s Turing Award, and in 1998, received the </span><a href="https://www.nsf.gov/od/nms/medal.jsp"><span class="span4">National Medal of Science</span></a><span class="span3"> for their work on the C language and Unix.</span></p><p class="para4"><span class="span3">But Doug McIlroy and J.F. Ossanna deserve their share of praise, too. All four of them are true Command Line Heroes.</span></p></body></html>
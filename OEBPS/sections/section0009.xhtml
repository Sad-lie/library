<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">Learn how file input and output works in C</span></p><p class="para4"><span class="span3">By Jim Hall </span></p><p class="para4"><span class="span3">If you want to learn input and output in C, start by looking at the </span><span class="span8">stdio.h</span><span class="span3"> include file. As you might guess from the name, that file defines all the standard (&quot;std&quot;) input and output (&quot;io&quot;) functions.</span></p><p class="para4"><span class="span3">The first </span><span class="span8">stdio.h</span><span class="span3"> function that most people learn is the </span><span class="span8">printf</span><span class="span3"> function to print formatted output. Or the </span><span class="span8">puts</span><span class="span3"> function to print a simple string. Those are great functions to print information to the user, but if you want to do more than that, you&apos;ll need to explore other functions.</span></p><p class="para4"><span class="span3">You can learn about some of these functions and methods by writing a replica of a common Linux command. The </span><span class="span8">cp</span><span class="span3"> command will copy one file to another. If you look at the </span><span class="span8">cp</span><span class="span3"> man page, you&apos;ll see that </span><span class="span8">cp</span><span class="span3"> supports a broad set of command-line parameters and options. But in the simplest case, </span><span class="span8">cp</span><span class="span3"> supports copying one file to another:</span></p><p class="para7"><span class="span6">cp infile outfile</span></p><p class="para4"><span class="span3">You can write your own version of this </span><span class="span8">cp</span><span class="span3"> command in C by using only a few basic functions to </span><span class="span9">read</span><span class="span3"> and </span><span class="span9">write</span><span class="span3"> files.</span></p><p class="para5"><span class="span5">Reading and writing one character at a time</span></p><p class="para4"><span class="span3">You can easily do input and output using the </span><span class="span8">fgetc</span><span class="span3"> and </span><span class="span8">fputc</span><span class="span3"> functions. These read and write data one character at a time. The usage is defined in </span><span class="span8">stdio.h</span><span class="span3"> and is quite straightforward: </span><span class="span8">fgetc</span><span class="span3"> reads (gets) a single character from a file, and </span><span class="span8">fputc</span><span class="span3"> puts a single character into a file.</span></p><p class="para4"> </p><p class="para6"><span class="span6">int </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgetc.html"><span class="span7">fgetc</span></a><span class="span6">(FILE *stream);</span></p><p class="para7"><span class="span6">int </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fputc.html"><span class="span7">fputc</span></a><span class="span6">(int c, FILE *stream);</span></p><p class="para4"><span class="span3">Writing the </span><span class="span8">cp</span><span class="span3"> command requires accessing files. In C, you open a file using the </span><span class="span8">fopen</span><span class="span3"> function, which takes two arguments: the </span><span class="span9">name</span><span class="span3"> of the file and the </span><span class="span9">mode</span><span class="span3"> you want to use. The mode is usually </span><span class="span8">r</span><span class="span3"> to read from a file or </span><span class="span8">w</span><span class="span3"> to write to a file. The mode supports other options too, but for this tutorial, just focus on reading and writing.</span></p><p class="para4"><span class="span3">Copying one file to another then becomes a matter of opening the source and destination files, then </span><span class="span9">reading one character at a time</span><span class="span3"> from the first file, then </span><span class="span9">writing that character</span><span class="span3"> to the second file. The </span><span class="span8">fgetc</span><span class="span3"> function returns either the single character read from the input file or the </span><span class="span9">end of file</span><span class="span3"> (</span><span class="span8">EOF</span><span class="span3">) marker when the file is done. Once you&apos;ve read </span><span class="span8">EOF</span><span class="span3">, you&apos;ve finished copying and you can close both files. That code looks like this:</span></p><p class="para6"><span class="span6">  do {</span></p><p class="para6"><span class="span6">    ch = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgetc.html"><span class="span7">fgetc</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">    if (ch != EOF) {</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fputc.html"><span class="span7">fputc</span></a><span class="span6">(ch, outfile);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para7"><span class="span6">  } while (ch != EOF);</span></p><p class="para4"><span class="span3">You can write your own </span><span class="span8">cp</span><span class="span3"> program with this loop to read and write one character at a time by using the </span><span class="span8">fgetc</span><span class="span3"> and </span><span class="span8">fputc</span><span class="span3"> functions. The </span><span class="span8">cp.c</span><span class="span3"> source code looks like this:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main(int argc, char **argv)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  FILE *infile;</span></p><p class="para6"><span class="span6">  FILE *outfile;</span></p><p class="para6"><span class="span6">  int ch;</span></p><p class="para6"><span class="span6">  /* parse the command line */</span></p><p class="para6"><span class="span6">  /* usage: cp infile outfile */</span></p><p class="para6"><span class="span6">  if (argc != 3) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Incorrect usage\n&quot;);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Usage: cp infile outfile\n&quot;);</span></p><p class="para6"><span class="span6">    return 1;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* open the input file */</span></p><p class="para6"><span class="span6">  infile = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(argv[1], &quot;r&quot;);</span></p><p class="para6"><span class="span6">  if (infile == NULL) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Cannot open file for reading: %s\n&quot;, argv[1]);</span></p><p class="para6"><span class="span6">    return 2;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"> </p><p class="para6"><span class="span6">  /* open the output file */</span></p><p class="para6"><span class="span6">  outfile = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(argv[2], &quot;w&quot;);</span></p><p class="para6"><span class="span6">  if (outfile == NULL) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Cannot open file for writing: %s\n&quot;, argv[2]);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">    return 3;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* copy one file to the other */</span></p><p class="para6"><span class="span6">  /* use fgetc and fputc */</span></p><p class="para6"><span class="span6">  do {</span></p><p class="para6"><span class="span6">    ch = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgetc.html"><span class="span7">fgetc</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">    if (ch != EOF) {</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fputc.html"><span class="span7">fputc</span></a><span class="span6">(ch, outfile);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">  } while (ch != EOF);</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(outfile);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">And you can compile that </span><span class="span8">cp.c</span><span class="span3"> file into a full executable using the GNU Compiler Collection (GCC):</span></p><p class="para7"><span class="span6">$ gcc -Wall -o cp cp.c</span></p><p class="para4"><span class="span3">The </span><span class="span8">-o cp</span><span class="span3"> option tells the compiler to save the compiled program into the </span><span class="span8">cp</span><span class="span3"> program file. The </span><span class="span8">-Wall</span><span class="span3"> option tells the compiler to turn on all warnings. If you don&apos;t see any warnings, that means everything worked correctly.</span></p><p class="para5"><span class="span5">Reading and writing blocks of data</span></p><p class="para4"><span class="span3">Programming your own </span><span class="span8">cp</span><span class="span3"> command by reading and writing data one character at a time does the job, but it&apos;s not very fast. You might not notice when copying &quot;everyday&quot; files like documents and text files, but you&apos;ll really notice the difference when copying large files or when copying files over a network. Working on one character at a time requires significant overhead.</span></p><p class="para4"><span class="span3">A better way to write this </span><span class="span8">cp</span><span class="span3"> command is by reading a chunk of the input into memory (called a </span><span class="span9">buffer</span><span class="span3">), then writing that collection of data to the second file. This is much faster because the program can read more of the data at one time, which requires fewer &quot;reads&quot; from the file.</span></p><p class="para4"><span class="span3">You can read a file into a variable by using the </span><span class="span8">fread</span><span class="span3"> function. This function takes several arguments: the array or memory buffer to read data into (</span><span class="span8">ptr</span><span class="span3">), the size of the smallest thing you want to read (</span><span class="span8">size</span><span class="span3">), how many of those things you want to read (</span><span class="span8">nmemb</span><span class="span3">), and the file to read from (</span><span class="span8">stream</span><span class="span3">):</span></p><p class="para7"><span class="span6">size_t </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fread.html"><span class="span7">fread</span></a><span class="span6">(void *ptr, size_t size, size_t nmemb, FILE *stream);</span></p><p class="para4"><span class="span3">The different options provide quite a bit of flexibility for more advanced file input and output, such as reading and writing files with a certain data structure. But in the simple case of </span><span class="span9">reading data from one file</span><span class="span3"> and </span><span class="span9">writing data to another file</span><span class="span3">, you can use a buffer that is an array of characters.</span></p><p class="para4"><span class="span3">And you can write the buffer to another file using the </span><span class="span8">fwrite</span><span class="span3"> function. This uses a similar set of options to the </span><span class="span8">fread</span><span class="span3"> function: the array or memory buffer to read data from, the size of the smallest thing you need to write, how many of those things you need to write, and the file to write to.</span></p><p class="para7"><span class="span6">size_t </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fwrite.html"><span class="span7">fwrite</span></a><span class="span6">(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span></p><p class="para4"><span class="span3">In the case where the program reads a file into a buffer, then writes that buffer to another file, the array (</span><span class="span8">ptr</span><span class="span3">) can be an array of a fixed size. For example, you can use a </span><span class="span8">char</span><span class="span3"> array called </span><span class="span8">buffer</span><span class="span3"> that is 200 characters long.</span></p><p class="para4"><span class="span3">With that assumption, you need to change the loop in your </span><span class="span8">cp</span><span class="span3"> program to </span><span class="span9">read data from a file into a buffer</span><span class="span3"> then </span><span class="span9">write that buffer to another file</span><span class="span3">:</span></p><p class="para6"><span class="span6">  while (!</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/feof.html"><span class="span7">feof</span></a><span class="span6">(infile)) {</span></p><p class="para6"><span class="span6">    buffer_length = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fread.html"><span class="span7">fread</span></a><span class="span6">(buffer, sizeof(char), 200, infile);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fwrite.html"><span class="span7">fwrite</span></a><span class="span6">(buffer, sizeof(char), buffer_length, outfile);</span></p><p class="para7"><span class="span6">  }</span></p><p class="para4"><span class="span3">Here&apos;s the full source code to your updated </span><span class="span8">cp</span><span class="span3"> program, which now uses a buffer to read and write data:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main(int argc, char **argv)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  FILE *infile;</span></p><p class="para6"><span class="span6">  FILE *outfile;</span></p><p class="para6"><span class="span6">  char buffer[200];</span></p><p class="para6"><span class="span6">  size_t buffer_length;</span></p><p class="para6"><span class="span6">  /* parse the command line */</span></p><p class="para6"><span class="span6">  /* usage: cp infile outfile */</span></p><p class="para6"><span class="span6">  if (argc != 3) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Incorrect usage\n&quot;);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Usage: cp infile outfile\n&quot;);</span></p><p class="para6"><span class="span6">    return 1;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* open the input file */</span></p><p class="para6"><span class="span6">  infile = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(argv[1], &quot;r&quot;);</span></p><p class="para6"><span class="span6">  if (infile == NULL) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Cannot open file for reading: %s\n&quot;, argv[1]);</span></p><p class="para6"><span class="span6">    return 2;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* open the output file */</span></p><p class="para6"><span class="span6">  outfile = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(argv[2], &quot;w&quot;);</span></p><p class="para6"><span class="span6">  if (outfile == NULL) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, &quot;Cannot open file for writing: %s\n&quot;, argv[2]);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">    return 3;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* copy one file to the other */</span></p><p class="para6"><span class="span6">  /* use fread and fwrite */</span></p><p class="para6"><span class="span6">  while (!</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/feof.html"><span class="span7">feof</span></a><span class="span6">(infile)) {</span></p><p class="para6"><span class="span6">    buffer_length = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fread.html"><span class="span7">fread</span></a><span class="span6">(buffer, sizeof(char), 200, infile);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fwrite.html"><span class="span7">fwrite</span></a><span class="span6">(buffer, sizeof(char), buffer_length, outfile);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(infile);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(outfile);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Since you want to compare this program to the other program, save this source code as </span><span class="span8">cp2.c</span><span class="span3">. You can compile that updated program using GCC:</span></p><p class="para7"><span class="span6">$ gcc -Wall -o cp2 cp2.c</span></p><p class="para4"><span class="span3">As before, the </span><span class="span8">-o cp2</span><span class="span3"> option tells the compiler to save the compiled program into the </span><span class="span8">cp2</span><span class="span3"> program file. The </span><span class="span8">-Wall</span><span class="span3"> option tells the compiler to turn on all warnings. If you don&apos;t see any warnings, that means everything worked correctly.</span></p><p class="para5"><span class="span5">Yes, it really is faster</span></p><p class="para4"><span class="span3">Reading and writing data using buffers is the better way to write this version of the </span><span class="span8">cp</span><span class="span3"> program. Because it reads chunks of a file into memory at once, the program doesn&apos;t need to </span><span class="span3">read data as often. You might not notice a difference in using either method on smaller files, but you&apos;ll really see the difference if you need to copy something that&apos;s much larger or when copying data on slower media like over a network connection.</span></p><p class="para4"><span class="span3">I ran a runtime comparison using the Linux </span><span class="span8">time</span><span class="span3"> command. This command runs another program, then tells you how long that program took to complete. For my test, I wanted to see the difference in time, so I copied a 628MB CD-ROM image file I had on my system.</span></p><p class="para4"><span class="span3">I first copied the image file using the standard Linux </span><span class="span8">cp</span><span class="span3"> command to see how long that takes. By running the Linux </span><span class="span8">cp</span><span class="span3"> command first, I also eliminated the possibility that Linux&apos;s built-in file-cache system wouldn&apos;t give my program a false performance boost. The test with Linux </span><span class="span8">cp</span><span class="span3"> took much less than one second to run:</span></p><p class="para6"><span class="span6">$ time cp FD13LIVE.iso tmpfile</span></p><p class="para6"><span class="span6">real    0m0.040s</span></p><p class="para6"><span class="span6">user    0m0.001s</span></p><p class="para7"><span class="span6">sys     0m0.003s</span></p><p class="para4"><span class="span3">Copying the same file using my own version of the </span><span class="span8">cp</span><span class="span3"> command took significantly longer. Reading and writing one character at a time took almost five seconds to copy the file:</span></p><p class="para6"><span class="span6">$ time ./cp FD13LIVE.iso tmpfile</span></p><p class="para6"><span class="span6">real    0m4.823s</span></p><p class="para6"><span class="span6">user    0m4.100s</span></p><p class="para7"><span class="span6">sys     0m0.571s</span></p><p class="para4"><span class="span3">Reading data from an input into a buffer and then writing that buffer to an output file is much faster. Copying the file using this method took less than a second:</span></p><p class="para6"><span class="span6">$ time ./cp2 FD13LIVE.iso tmpfile</span></p><p class="para6"><span class="span6">real    0m0.944s</span></p><p class="para6"><span class="span6">user    0m0.224s</span></p><p class="para7"><span class="span6">sys     0m0.608s</span></p><p class="para4"><span class="span3">My demonstration </span><span class="span8">cp</span><span class="span3"> program used a buffer that was 200 characters. I&apos;m sure the program would run much faster if I read more of the file into memory at once. But for this comparison, you can already see the huge difference in performance, even with a small, 200 character buffer.</span></p><p class="para4"> </p></body></html>
<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">Write a chess game using bit-fields and masks</span></p><p class="para4"><span class="span3">By Jim Hall</span></p><p class="para4"><span class="span3">Let&apos;s say you were writing a chess game in C. One way to track the pieces on the board is by defining a structure that defines each possible piece on the board, and its color, so every square contains an element from that structure. For example, you might have a structure that looks like this:</span></p><p class="para6"><span class="span6">struct chess_pc {</span></p><p class="para6"><span class="span6">   int piece;</span></p><p class="para6"><span class="span6">   int is_black;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">With this programming structure, your program will know what piece is in every square and its color. You can quickly identify if the piece is a pawn, rook, knight, bishop, queen, or king—and if the piece is black or white. But there&apos;s a more straightforward way to track the same information while using less data and memory. Rather than storing a structure of two </span><span class="span8">int</span><span class="span3"> values for every square on a chessboard, we can store a single </span><span class="span8">int</span><span class="span3"> value and use binary </span><span class="span9">bit-fields</span><span class="span3"> and </span><span class="span9">masks</span><span class="span3"> to identify the pieces and color in each square.</span></p><p class="para5"><span class="span5">Bits and binary</span></p><p class="para4"><span class="span3">When using bit-fields to represent data, it helps to think like a computer. Let&apos;s start by listing the possible chess pieces and assigning a number to each. I&apos;ll help us along to the next step by representing the number in its binary form, the way the computer would track it. Remember that binary numbers are made up of </span><span class="span9">bits</span><span class="span3">, which are either zero or one.</span></p><p class="para8"><span class="span11">00000000</span><span class="span8">: </span><span class="span3">empty (0) </span></p><p class="para8"><span class="span11">00000001</span><span class="span8">: </span><span class="span3">pawn (1) </span></p><p class="para8"><span class="span11">00000010</span><span class="span8">: </span><span class="span3">rook (2) </span></p><p class="para8"><span class="span11">00000011</span><span class="span8">: </span><span class="span3">knight (3) </span></p><p class="para8"><span class="span11">00000100</span><span class="span8">: </span><span class="span3">bishop (4) </span></p><p class="para8"><span class="span11">00000101</span><span class="span8">: </span><span class="span3">queen (5) </span></p><p class="para4"><span class="span11">00000110</span><span class="span8">: </span><span class="span3">king (6) </span></p><p class="para4"><span class="span3">To list all pieces on a chessboard, we only need the three bits that represent (from right to left) the values 1, 2, and 4. For example, the number 6 is binary </span><span class="span8">110</span><span class="span3">. All of the other bits in the binary representation of 6 are zeroes.</span></p><p class="para4"><span class="span3">And with a bit of cleverness, we can use one of those extra always-zero bits to track if a piece is black or white. We can use the number 8 (binary </span><span class="span8">00001000</span><span class="span3">) to indicate if a piece is black. If this bit is 1, it&apos;s black; if it&apos;s 0, it&apos;s white. That&apos;s called a </span><span class="span9">bit-field</span><span class="span3">, which we can pull out later using a binary </span><span class="span9">mask</span><span class="span3">.</span></p><p class="para5"><span class="span5">Storing data with bit-fields</span></p><p class="para4"><span class="span3">To write a chess program using bit-fields and masks, we might start with these definitions:</span></p><p class="para6"><span class="span6">/* game pieces */</span></p><p class="para6"><span class="span6">#define EMPTY 0</span></p><p class="para6"><span class="span6">#define PAWN 1</span></p><p class="para6"><span class="span6">#define ROOK 2</span></p><p class="para6"><span class="span6">#define KNIGHT 3</span></p><p class="para6"><span class="span6">#define BISHOP 4</span></p><p class="para6"><span class="span6">#define QUEEN 5</span></p><p class="para6"><span class="span6">#define KING 6</span></p><p class="para6"><span class="span6">/* piece color (bit-field) */</span></p><p class="para6"><span class="span6">#define BLACK 8</span></p><p class="para6"><span class="span6">#define WHITE 0</span></p><p class="para6"><span class="span6">/* piece only (mask) */</span></p><p class="para7"><span class="span6">#define PIECE 7</span></p><p class="para4"><span class="span3">When you assign a value to a square, such as when initializing the chessboard, you can assign a single </span><span class="span8">int</span><span class="span3"> value to track both the piece and its color. For example, to store a black rook in position 0,0 of an array, you would use this code:</span></p><p class="para6"><span class="span6">  int board[8][8];</span></p><p class="para6"><span class="span6">..</span></p><p class="para7"><span class="span6">  board[0][0] = BLACK | ROOK;</span></p><p class="para4"><span class="span3">The </span><span class="span8">|</span><span class="span3"> is a binary OR, which means the computer will combine the bits from two numbers. For every bit position, if that bit from </span><span class="span9">either</span><span class="span3"> number is 1, the result for that bit position is also 1. Binary OR of the value </span><span class="span8">BLACK</span><span class="span3"> (8, or binary </span><span class="span8">00001000</span><span class="span3">) and the value </span><span class="span8">ROOK </span><span class="span3">(2, or binary </span><span class="span8">00000010</span><span class="span3">) is binary </span><span class="span8">00001010</span><span class="span3">, or 10:</span></p><p class="para6"><span class="span6">    00001000 = 8</span></p><p class="para6"><span class="span6"> OR 00000010 = 2</span></p><p class="para6"><span class="span6">    ________</span></p><p class="para7"><span class="span6">    00001010 = 10</span></p><p class="para4"><span class="span3">Similarly, to store a white pawn in position 6,0 of the array, you could use this:</span></p><p class="para7"><span class="span6">  board[6][0] = WHITE | PAWN;</span></p><p class="para4"><span class="span3">This stores the value 1 because the binary OR of </span><span class="span8">WHITE</span><span class="span3"> (0) and </span><span class="span8">PAWN</span><span class="span3"> (1) is just 1:</span></p><p class="para6"><span class="span6">    00000000 = 0</span></p><p class="para6"><span class="span6"> OR 00000001 = 1</span></p><p class="para6"><span class="span6">    ________</span></p><p class="para7"><span class="span6">    00000001 = 1</span></p><p class="para5"><span class="span5">Getting data out with masks</span></p><p class="para4"><span class="span3">During the chess game, the program will need to know what piece is in a square and its color. We can separate the piece using a binary mask.</span></p><p class="para4"><span class="span3">For example, the program might need to know the contents of a specific square on the board during the chess game, such as the array element at </span><span class="span8">board[5][3]</span><span class="span3">. What piece is there, and is it black or white? To identify the chess piece, combine the element&apos;s value with the </span><span class="span8">PIECE</span><span class="span3"> mask using the binary AND:</span></p><p class="para6"><span class="span6">  int board[8][8];</span></p><p class="para6"><span class="span6">  int piece;</span></p><p class="para6"><span class="span6">..</span></p><p class="para7"><span class="span6">  piece = board[5][3] &amp; PIECE;</span></p><p class="para4"><span class="span3">The binary AND operator (</span><span class="span8">&amp;</span><span class="span3">) combines two binary values so that for any bit position, if that bit in </span><span class="span9">both</span><span class="span3"> numbers is 1, then the result is also 1. For example, if the value of </span><span class="span8">board[5][3]</span><span class="span3"> is 11 (binary </span><span class="span8">00001011</span><span class="span3">), then the binary AND of 11 and the mask PIECE (7, or binary </span><span class="span8">00000111</span><span class="span3">) is binary </span><span class="span8">00000011</span><span class="span3">, or 3. This is a knight, which also has the value 3.</span></p><p class="para6"><span class="span6">    00001011 = 11</span></p><p class="para6"><span class="span6">AND 00000111 = 7</span></p><p class="para6"><span class="span6">    ________</span></p><p class="para7"><span class="span6">    00000011 = 3</span></p><p class="para4"><span class="span3">Separating the piece&apos;s color is a simple matter of using binary AND with the value and the </span><span class="span8">BLACK</span><span class="span3"> bit-field. For example, you might write this as a function called </span><span class="span8">is_black</span><span class="span3"> to determine if a piece is either black or white:</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">is_black(int piece)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  return (piece &amp; BLACK);</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">This works because the value </span><span class="span8">BLACK</span><span class="span3"> is 8, or binary </span><span class="span8">00001000</span><span class="span3">. And in the C programming language, any non-zero value is treated as True, and zero is always False. So </span><span class="span8">is_black(board[5][3])</span><span class="span3"> will return a True value (8) if the piece in array element </span><span class="span8">5,3</span><span class="span3"> is black and will return a False value (0) if it is white.</span></p><p class="para5"><span class="span5">Bit fields</span></p><p class="para4"><span class="span3">Using bit-fields and masks is a common method to combine data without using structures. They are worth adding to your programmer&apos;s &quot;tool kit.&quot; While data structures are a valuable tool for ordered programming where you need to track related data, using separate elements to track single On or Off values (such as the colors of chess pieces) is less efficient. In these cases, consider using bit-fields and masks to combine your data more efficiently.</span></p><p class="para4"> </p></body></html>
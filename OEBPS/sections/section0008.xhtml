<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">Short option parsing using getopt</span></p><p class="para4"><span class="span3">By Jim Hall </span></p><p class="para4"><span class="span3">Writing a C program to process files is easy when you already know what files you&apos;ll operate on and what actions to take. If you &quot;hard code&quot; the filename into your program, or if your program is coded to do things only one way, then your program will always know what to do.</span></p><p class="para4"><span class="span3">But you can make your program much more flexible if it can respond to the user every time the program runs. Let your user tell your program what files to use or how to do things differently. And for that, you need to read the command line.</span></p><p class="para5"><span class="span5">Reading the command line</span></p><p class="para4"><span class="span3">When you write a program in C, you might start with the declaration:</span></p><p class="para7"><span class="span6">int main()</span></p><p class="para4"><span class="span3">That&apos;s the simplest way to start a C program. But if you add these standard parameters in the parentheses, your program can read the options given to it on the command line:</span></p><p class="para7"><span class="span6">int main(int argc, char **argv)</span></p><p class="para4"><span class="span3">The </span><span class="span8">argc</span><span class="span3"> variable is the argument count or the number of arguments on the command line. This will always be a number that&apos;s at least one.</span></p><p class="para4"><span class="span3">The </span><span class="span8">argv</span><span class="span3"> variable is a double pointer, an array of strings, that contains the arguments from the command line. The first entry in the array, </span><span class="span8">*argv[0]</span><span class="span3">, is always the name of the program. The other elements of the </span><span class="span8">**argv</span><span class="span3"> array contain the rest of the command-line arguments.</span></p><p class="para4"><span class="span3">I&apos;ll write a simple program to echo back the options given to it on the command line. This is similar to the Linux </span><span class="span8">echo</span><span class="span3"> command, except it also prints the name of the program. It also prints each command-line option on its own line using the </span><span class="span8">puts</span><span class="span3"> function:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main(int argc, char **argv)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int i;</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;argc=%d\n&quot;, argc); /* debugging */</span></p><p class="para6"><span class="span6">  for (i = 0; i &lt; argc; i++) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(argv[i]);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Compile this program and run it with some command-line options, and you&apos;ll see your command line printed back to you, each item on its own line:</span></p><p class="para6"><span class="span6">$ ./echo this program can read the command line</span></p><p class="para6"><span class="span6">argc=8</span></p><p class="para6"><span class="span6">./echo</span></p><p class="para6"><span class="span6">this</span></p><p class="para6"><span class="span6">program</span></p><p class="para6"><span class="span6">can</span></p><p class="para6"><span class="span6">read</span></p><p class="para6"><span class="span6">the</span></p><p class="para6"><span class="span6">command</span></p><p class="para7"><span class="span6">line</span></p><p class="para4"><span class="span3">This command line sets the program&apos;s </span><span class="span8">argc</span><span class="span3"> to </span><span class="span8">8</span><span class="span3">, and the </span><span class="span8">**argv</span><span class="span3"> array contains eight entries: the name of the program, plus the seven words the user entered. And as always in C programs, the array starts at zero, so the elements are numbered 0, 1, 2, 3, 4, 5, 6, 7. That&apos;s why you can process the command line with the </span><span class="span8">for</span><span class="span3"> loop using the comparison </span><span class="span8">i &lt; argc</span><span class="span3">.</span></p><p class="para4"><span class="span3">You can use this to write your own versions of the Linux </span><span class="span8">cat</span><span class="span3"> or </span><span class="span8">cp</span><span class="span3"> commands. The </span><span class="span8">cat</span><span class="span3"> command&apos;s basic functionality displays the contents of one or more files. Here&apos;s a simple version of </span><span class="span8">cat</span><span class="span3"> that reads the filenames from the command line:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">void</span></p><p class="para6"><span class="span6">copyfile(FILE *in, FILE *out)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int ch;</span></p><p class="para6"><span class="span6">  while ((ch = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgetc.html"><span class="span7">fgetc</span></a><span class="span6">(in)) != EOF) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fputc.html"><span class="span7">fputc</span></a><span class="span6">(ch, out);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main(int argc, char **argv)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int i;</span></p><p class="para6"><span class="span6">  FILE *fileptr;</span></p><p class="para6"><span class="span6">  for (i = 1; i &lt; argc; i++) {</span></p><p class="para6"><span class="span6">    fileptr = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(argv[i], &quot;r&quot;);</span></p><p class="para6"><span class="span6">    if (fileptr != NULL) {</span></p><p class="para6"><span class="span6">      copyfile(fileptr, stdout);</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(fileptr);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">This simple version of </span><span class="span8">cat</span><span class="span3"> reads a list of filenames from the command line and displays the contents of each file to the standard output, one character at a time. For example, if I have one file called </span><span class="span8">hello.txt</span><span class="span3"> that contains a few lines of text, I can display its contents with my own </span><span class="span8">cat</span><span class="span3"> command:</span></p><p class="para6"><span class="span6">$ ./cat hello.txt </span></p><p class="para6"><span class="span6">Hi there!</span></p><p class="para7"><span class="span6">This is a sample text file.</span></p><p class="para4"><span class="span3">Using this sample program as a starting point, you can write your own versions of other Linux commands, such as the </span><span class="span8">cp</span><span class="span3"> program, by reading only two filenames: one file to read from and another file to write the copy.</span></p><p class="para5"><span class="span5">Reading command-line options</span></p><p class="para4"><span class="span3">Reading filenames and other text from the command line is great, but what if you want your program to change its behavior based on the </span><span class="span9">options</span><span class="span3"> the user gives it? For example, the Linux </span><span class="span8">cat</span><span class="span3"> command supports several command-line options, including:</span></p><p class="para8"><span class="span8">-b</span><span class="span3"> Put line numbers next to non-blank lines </span></p><p class="para8"><span class="span8">-E</span><span class="span3"> Show the ends of lines as </span><span class="span8">$</span><span class="span3"> </span></p><p class="para8"><span class="span8">-n </span><span class="span3">Put line numbers next to all lines </span></p><p class="para8"><span class="span8">-s</span><span class="span3"> Suppress printing repeated blank lines </span></p><p class="para8"><span class="span8">-T</span><span class="span3"> Show tabs as </span><span class="span8">^I</span><span class="span3"> </span></p><p class="para4"><span class="span8">-v </span><span class="span3">Verbose; show non-printing characters using </span><span class="span8">^x</span><span class="span3"> and </span><span class="span8">M-x</span><span class="span3"> notation, except for new lines and tabs </span></p><p class="para4"><span class="span3">These </span><span class="span9">single-letter</span><span class="span3"> options are called </span><span class="span9">short options</span><span class="span3">, and they always start with a single hyphen character. You usually see these short options written separately, such as </span><span class="span8">cat -E -n</span><span class="span3">, but you can also combine the short options into a single </span><span class="span9">option string</span><span class="span3"> such as </span><span class="span8">cat -En</span><span class="span3">.</span></p><p class="para4"><span class="span3">Fortunately, there&apos;s an easy way to read these from the command line. All Linux and Unix systems include a special C library called </span><span class="span8">getopt</span><span class="span3">, defined in the </span><span class="span8">unistd.h</span><span class="span3"> header file. You can use </span><span class="span8">getopt</span><span class="span3"> in your program to read these short options.</span></p><p class="para4"><span class="span3">Unlike other Unix systems, </span><span class="span8">getopt</span><span class="span3"> on Linux will always ensure your short options appear at the front of your command line. For example, say a user types </span><span class="span8">cat -E file -n</span><span class="span3">. The </span><span class="span8">-E</span><span class="span3"> option is upfront, but the </span><span class="span8">-n</span><span class="span3"> option is after the filename. But if you use Linux </span><span class="span8">getopt</span><span class="span3">, your program will always behave as though the user types </span><span class="span8">cat -E -n file</span><span class="span3">. That makes processing a breeze because </span><span class="span8">getopt</span><span class="span3"> can parse the short options, leaving you a list of filenames on the command line that your program can read using the </span><span class="span8">**argv</span><span class="span3"> array.</span></p><p class="para4"><span class="span3">You use </span><span class="span8">getopt</span><span class="span3"> like this:</span></p><p class="para6"><span class="span6">       #include &lt;unistd.h&gt;</span></p><p class="para7"><span class="span6">       int getopt(int argc, char **argv, char *optstring);</span></p><p class="para4"><span class="span3">The option string </span><span class="span8">optstring</span><span class="span3"> contains a list of the valid option characters. If your program only allows the </span><span class="span8">-E</span><span class="span3"> and </span><span class="span8">-n</span><span class="span3"> options, you use &quot;</span><span class="span8">En&quot;</span><span class="span3"> as your option string.</span></p><p class="para4"><span class="span3">You usually use </span><span class="span8">getopt</span><span class="span3"> in a loop to parse the command line for options. At each </span><span class="span8">getopt</span><span class="span3"> call, the function returns the next short option it finds on the command line or the value </span><span class="span8">&apos;?&apos;</span><span class="span3"> for any unrecognized short options. When </span><span class="span8">getopt</span><span class="span3"> can&apos;t find any more short options, it returns </span><span class="span8">-1</span><span class="span3"> and sets the global variable </span><span class="span8">optind</span><span class="span3"> to the next element in </span><span class="span8">**argv</span><span class="span3"> after all the short options.</span></p><p class="para4"><span class="span3">Let&apos;s look at a simple example. This demo program isn&apos;t a full replacement of </span><span class="span8">cat</span><span class="span3"> with all the options, but it can parse its command line. Every time it finds a valid command-line option, it prints a short message to indicate it was found. In your own programs, you might instead set a variable or take some other action that responds to that command-line option:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;unistd.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main(int argc, char **argv)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int i;</span></p><p class="para6"><span class="span6">  int option;</span></p><p class="para6"><span class="span6">  /* parse short options */</span></p><p class="para6"><span class="span6">  while ((option = getopt(argc, argv, &quot;bEnsTv&quot;)) != -1) {</span></p><p class="para6"><span class="span6">    switch (option) {</span></p><p class="para6"><span class="span6">    case &apos;b&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Put line numbers next to non-blank lines&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    case &apos;E&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Show the ends of lines as $&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    case &apos;n&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Put line numbers next to all lines&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    case &apos;s&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Suppress printing repeated blank lines&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    case &apos;T&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Show tabs as ^I&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    case &apos;v&apos;:</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Verbose&quot;);</span></p><p class="para6"><span class="span6">      break;</span></p><p class="para6"><span class="span6">    default:                          /* &apos;?&apos; */</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;What&apos;s that??&quot;);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* print the rest of the command line */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;------------------------------&quot;);</span></p><p class="para6"><span class="span6">  for (i = optind; i &lt; argc; i++) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(argv[i]);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">If you compile this program as </span><span class="span8">args</span><span class="span3">, you can try out different command lines to see how they parse the short options and always leave you with the rest of the command line. In the simplest case, with all the options up front, you get this:</span></p><p class="para6"><span class="span6">$ ./args -b -T file1 file2</span></p><p class="para6"><span class="span6">Put line numbers next to non-blank lines</span></p><p class="para6"><span class="span6">Show tabs as ^I</span></p><p class="para6"><span class="span6">------------------------------</span></p><p class="para6"><span class="span6">file1</span></p><p class="para7"><span class="span6">file2</span></p><p class="para4"><span class="span3">Now try the same command line but combine the two short options into a single option string:</span></p><p class="para6"><span class="span6">$ ./args -bT file1 file2</span></p><p class="para6"><span class="span6">Put line numbers next to non-blank lines</span></p><p class="para6"><span class="span6">Show tabs as ^I</span></p><p class="para6"><span class="span6">------------------------------</span></p><p class="para6"><span class="span6">file1</span></p><p class="para7"><span class="span6">file2</span></p><p class="para4"><span class="span3">If necessary, </span><span class="span8">getopt</span><span class="span3"> can &quot;reorder&quot; the command line to deal with short options that are out of order:</span></p><p class="para6"><span class="span6">$ ./args -E file1 file2 -T</span></p><p class="para6"><span class="span6">Show the ends of lines as $</span></p><p class="para6"><span class="span6">Show tabs as ^I</span></p><p class="para6"><span class="span6">------------------------------</span></p><p class="para6"><span class="span6">file1</span></p><p class="para7"><span class="span6">file2</span></p><p class="para4"><span class="span3">If your user gives an incorrect short option, </span><span class="span8">getopt</span><span class="span3"> prints a message:</span></p><p class="para6"><span class="span6">$ ./args -s -an file1 file2</span></p><p class="para6"><span class="span6">Suppress printing repeated blank lines</span></p><p class="para6"><span class="span6">./args: invalid option -- &apos;a&apos;</span></p><p class="para6"><span class="span6">What&apos;s that??</span></p><p class="para6"><span class="span6">Put line numbers next to all lines</span></p><p class="para6"><span class="span6">------------------------------</span></p><p class="para6"><span class="span6">file1</span></p><p class="para7"><span class="span6">file2</span></p><p class="para5"><span class="span5">Download the cheat sheet</span></p><p class="para4"><span class="span8">getopt</span><span class="span3"> can do lots more than what I&apos;ve shown. For example, short options can take their own options, such as </span><span class="span8">-s string</span><span class="span3"> or </span><span class="span8">-f file</span><span class="span3">. You can also tell </span><span class="span8">getopt</span><span class="span3"> to not display error messages when it finds unrecognized options. Read the </span><span class="span8">getopt(3)</span><span class="span3"> manual page using </span><span class="span8">man 3 getopt</span><span class="span3"> to learn more about what </span><span class="span8">getopt</span><span class="span3"> can do for you.</span></p><p class="para4"><span class="span3">If you&apos;re looking for gentle reminders on the syntax and structure of </span><span class="span8">getopt()</span><span class="span3"> and </span><span class="span8">getopt_long()</span><span class="span3">, </span><a href="https://opensource.com/downloads/c-getopt-cheat-sheet"><span class="span4">download my getopt cheat sheet</span></a><span class="span3">. One page demonstrates short options, and the other side demonstrates long options with minimum viable code and a listing of the global variables you need to know.</span></p><p class="para4"> </p></body></html>
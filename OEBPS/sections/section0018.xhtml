<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">How to write a good C main function</span></p><p class="para4"><span class="span3">By </span><span class="span3">Erik O&apos;Shaughnessy </span></p><p class="para4"><span class="span3">I know, Python and JavaScript are what the kids are writing all their crazy &quot;apps&quot; with these days. But don&apos;t be so quick to dismiss C—it&apos;s a capable and concise language that has a lot to offer. If you need speed, writing in C could be your answer. If you are looking for job security and the opportunity to learn how to hunt down </span><a href="https://www.owasp.org/index.php/Null_Dereference"><span class="span4">null pointer dereferences</span></a><span class="span3">, C could also be your answer! In this article, I&apos;ll explain how to structure a C file and write a C main function that handles command line arguments like a champ.</span></p><p class="para4"><span class="span10">Me</span><span class="span3">: a crusty Unix system programmer.</span><span class="span3"><br/></span><span class="span3"><br/></span><span class="span10">You</span><span class="span3">: someone with an editor, a C compiler, and some time to kill.</span></p><p class="para4"><span class="span9">Let&apos;s do this.</span></p><p class="para5"><span class="span5">A boring but correct C program</span></p><p class="para4"><span class="span3"> </span> </p><p class="para4"><span class="span3">A C program starts with a </span><span class="span10">main()</span><span class="span3"> function, usually kept in a file named </span><span class="span10">main.c</span><span class="span3">.</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">int main(int argc, char *argv[]) {</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">This program </span><span class="span9">compiles</span><span class="span3"> but doesn&apos;t </span><span class="span9">do</span><span class="span3"> anything.</span></p><p class="para6"><span class="span6">$ gcc main.c</span></p><p class="para6"><span class="span6">$ ./a.out -o foo -vv </span></p><p class="para7"><span class="span6">$</span></p><p class="para4"><span class="span3">Correct and boring.</span></p><p class="para5"><span class="span5">Main functions are unique</span></p><p class="para4"><span class="span3">The </span><span class="span10">main()</span><span class="span3"> function is the first function in your program that is executed when it begins executing, but it&apos;s not the first function executed. The </span><span class="span9">first</span><span class="span3"> function is </span><span class="span10">_start()</span><span class="span3">, which is typically provided by the C runtime library, linked in automatically when your program is compiled. The details are highly dependent on the operating system and compiler toolchain, so I&apos;m going to pretend I didn&apos;t mention it.</span></p><p class="para4"><span class="span3">The </span><span class="span10">main()</span><span class="span3"> function has two arguments that traditionally are called </span><span class="span10">argc</span><span class="span3"> and </span><span class="span10">argv</span><span class="span3"> and return a signed integer. Most Unix environments expect programs to return </span><span class="span10">0</span><span class="span3"> (zero) on success and </span><span class="span10">-1</span><span class="span3"> (negative one) on failure.</span></p><table class="table1"><tbody><tr class="rowTable0"><td class="cellTable18"><p class="para0"><span class="span18">Argument</span></p></td><td class="cellTable19"><p class="para0"><span class="span18">Name</span></p></td><td class="cellTable20"><p class="para0"><span class="span18">Description</span></p></td></tr><tr class="rowTable0"><td class="cellTable21"><p class="para1"><span class="span12">argc</span></p></td><td class="cellTable22"><p class="para1"><span class="span12">Argument count</span></p></td><td class="cellTable23"><p class="para1"><span class="span12">Length of the argument vector</span></p></td></tr><tr class="rowTable0"><td class="cellTable24"><p class="para1"><span class="span12">argv</span></p></td><td class="cellTable25"><p class="para1"><span class="span12">Argument vector</span></p></td><td class="cellTable26"><p class="para1"><span class="span12">Array of character pointers</span></p></td></tr></tbody></table><p class="para4"><span class="span3">The argument vector, </span><span class="span10">argv</span><span class="span3">, is a tokenized representation of the command line that invoked your program. In the example above, </span><span class="span10">argv</span><span class="span3"> would be a list of the following strings:</span></p><p class="para7"><span class="span6">argv = [ &quot;/path/to/a.out&quot;, &quot;-o&quot;, &quot;foo&quot;, &quot;-vv&quot; ];</span></p><p class="para4"><span class="span3">The argument vector is guaranteed to always have at least one string in the first index, </span><span class="span10">argv[0]</span><span class="span3">, which is the full path to the program executed.</span></p><p class="para5"><span class="span5">Anatomy of a main.c file</span></p><p class="para4"><span class="span3">When I write a </span><span class="span10">main.c</span><span class="span3"> from scratch, it&apos;s usually structured like this:</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">/* 0 copyright/licensing */</span></p><p class="para6"><span class="span6">/* 1 includes */</span></p><p class="para6"><span class="span6">/* 2 defines */</span></p><p class="para6"><span class="span6">/* 3 external declarations */</span></p><p class="para6"><span class="span6">/* 4 typedefs */</span></p><p class="para6"><span class="span6">/* 5 global variable declarations */</span></p><p class="para6"><span class="span6">/* 6 function prototypes */</span></p><p class="para6"><span class="span6">int main(int argc, char *argv[]) {</span></p><p class="para6"><span class="span6">/* 7 command-line parsing */</span></p><p class="para6"><span class="span6">}</span></p><p class="para7"><span class="span6">/* 8 function declarations */</span></p><p class="para4"><span class="span3">I&apos;ll talk about each of these numbered sections, except for zero, below. If you have to put copyright or licensing text in your source, put it there.</span></p><p class="para4"><span class="span3">Another thing I won&apos;t talk about adding to your program is comments.</span></p><p class="para6"><span class="span6">&quot;Comments lie.&quot;</span></p><p class="para7"><span class="span6">- A cynical but smart and good looking programmer.</span></p><p class="para4"><span class="span3">Instead of comments, use meaningful function and variable names.</span></p><p class="para4"><span class="span3">Appealing to the inherent laziness of programmers, once you add comments, you&apos;ve doubled your maintenance load. If you change or refactor the code, you need to update or expand the comments. Over time, the code mutates away from anything resembling what the comments describe.</span></p><p class="para4"><span class="span3">If you have to write comments, do not write about </span><span class="span9">what</span><span class="span3"> the code is doing. Instead, write about </span><span class="span9">why</span><span class="span3"> the code is doing what it&apos;s doing. Write comments that you would want to read five years from now when you&apos;ve forgotten everything about this code. And the fate of the world is depending on you. </span><span class="span9">No pressure</span><span class="span3">.</span></p><p class="para11"><span class="span19">1. Includes</span></p><p class="para4"><span class="span3">The first things I add to a </span><span class="span10">main.c</span><span class="span3"> file are includes to make a multitude of standard C library functions and variables available to my program. The standard C library does lots of things; explore header files in </span><span class="span10">/usr/include</span><span class="span3"> to find out what it can do for you.</span></p><p class="para4"><span class="span3">The </span><span class="span10">#include</span><span class="span3"> string is a </span><a href="https://en.wikipedia.org/wiki/C_preprocessor"><span class="span4">C preprocessor</span></a><span class="span3"> (cpp) directive that causes the inclusion of the referenced file, in its entirety, in the current file. Header files in C are usually named with a </span><span class="span10">.h</span><span class="span3"> extension and should not contain any executable code; only macros, defines, typedefs, and external variable and function prototypes. The string </span><span class="span10">&lt;header.h&gt;</span><span class="span3"> tells cpp to look for a file called </span><span class="span10">header.h</span><span class="span3"> in the system-defined header path, usually </span><span class="span10">/usr/include</span><span class="span3">.</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;stdlib.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;unistd.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;libgen.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;errno.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;string.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;getopt.h&gt;</span></p><p class="para7"><span class="span6">#include &lt;sys/types.h&gt;</span></p><p class="para4"><span class="span3">This is the minimum set of global includes that I&apos;ll include by default for the following stuff:</span></p><table class="table2"><tbody><tr class="rowTable0"><td class="cellTable27"><p class="para0"><span class="span10">#include File</span></p></td><td class="cellTable28"><p class="para0"><span class="span10">Stuff It Provides</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">stdio</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies FILE, stdin, stdout, stderr, and the fprint() family of functions</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">stdlib</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies malloc(), calloc(), and realloc()</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">unistd</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies EXIT_FAILURE, EXIT_SUCCESS</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">libgen</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies the basename() function</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">errno</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Defines the external errno variable and all the values it can take on</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">string</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies memcpy(), memset(), and the strlen() family of functions</span></p></td></tr><tr class="rowTable0"><td class="cellTable29"><p class="para1"><span class="span3">getopt</span></p></td><td class="cellTable30"><p class="para1"><span class="span3">Supplies external optarg, opterr, optind, and getopt() function</span></p></td></tr><tr class="rowTable0"><td class="cellTable31"><p class="para1"><span class="span3">sys/types</span></p></td><td class="cellTable32"><p class="para1"><span class="span3">Typedef shortcuts like uint32_t and uint64_t</span></p></td></tr></tbody></table><p class="para11"><span class="span19">2. Defines</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">#define OPTSTR &quot;vi:o:f:h&quot;</span></p><p class="para6"><span class="span6">#define USAGE_FMT  &quot;%s [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]&quot;</span></p><p class="para6"><span class="span6">#define ERR_FOPEN_INPUT  &quot;fopen(input, r)&quot;</span></p><p class="para6"><span class="span6">#define ERR_FOPEN_OUTPUT &quot;fopen(output, w)&quot;</span></p><p class="para6"><span class="span6">#define ERR_DO_THE_NEEDFUL &quot;do_the_needful blew up&quot;</span></p><p class="para7"><span class="span6">#define DEFAULT_PROGNAME &quot;george&quot;</span></p><p class="para4"><span class="span3">This doesn&apos;t make a lot of sense right now, but the </span><span class="span10">OPTSTR</span><span class="span3"> define is where I will state what command line switches the program will recommend. Consult the </span><a href="https://linux.die.net/man/3/getopt"><span class="span20">getopt(3)</span></a><span class="span3"> man page to learn how </span><span class="span10">OPTSTR</span><span class="span3"> will affect </span><span class="span10">getopt()</span><span class="span3">&apos;s behavior.</span></p><p class="para4"><span class="span3">The </span><span class="span10">USAGE_FMT</span><span class="span3"> define is a </span><span class="span10">printf()</span><span class="span3">-style format string that is referenced in the </span><span class="span10">usage()</span><span class="span3"> function.</span></p><p class="para4"><span class="span3">I also like to gather string constants as </span><span class="span10">#defines</span><span class="span3"> in this part of the file. Collecting them makes it easier to fix spelling, reuse messages, and internationalize messages, if required.</span></p><p class="para4"><span class="span3">Finally, use all capital letters when naming a </span><span class="span10">#define</span><span class="span3"> to distinguish it from variable and function names. You can run the words together if you want or separate words with an underscore; just make sure they&apos;re all upper case.</span></p><p class="para11"><span class="span19">3. External declarations</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">extern int errno;</span></p><p class="para6"><span class="span6">extern char *optarg;</span></p><p class="para7"><span class="span6">extern int opterr, optind;</span></p><p class="para4"><span class="span3">An </span><span class="span10">extern</span><span class="span3"> declaration brings that name into the namespace of the current compilation unit (aka &quot;file&quot;) and allows the program to access that variable. Here we&apos;ve brought in the definitions for three integer variables and a character pointer. The </span><span class="span10">opt</span><span class="span3"> prefaced variables are used by the </span><span class="span10">getopt()</span><span class="span3"> function, and </span><span class="span10">errno</span><span class="span3"> is used as an out-of-band communication channel by the standard C library to communicate why a function might have failed.</span></p><p class="para11"><span class="span19">4. Typedefs</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">typedef struct {</span></p><p class="para6"><span class="span6">  int           verbose;</span></p><p class="para6"><span class="span6">  uint32_t      flags;</span></p><p class="para6"><span class="span6">  FILE         *input;</span></p><p class="para6"><span class="span6">  FILE         *output;</span></p><p class="para7"><span class="span6">} options_t;</span></p><p class="para4"><span class="span3">After external declarations, I like to declare </span><span class="span10">typedefs</span><span class="span3"> for structures, unions, and enumerations. Naming a </span><span class="span10">typedef</span><span class="span3"> is a religion all to itself; I strongly prefer a </span><span class="span10">_t</span><span class="span3"> suffix to indicate that the name is a type. In this example, I&apos;ve declared </span><span class="span10">options_t</span><span class="span3"> as a </span><span class="span10">struct</span><span class="span3"> with four members. C is a whitespace-neutral programming language, so I use whitespace to line up field names in the same column. I just like the way it looks. For the pointer declarations, I prepend the asterisk to the name to make it clear that it&apos;s a pointer.</span></p><p class="para11"><span class="span19">5. Global variable declarations</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para7"><span class="span6">int dumb_global_variable = -11;</span></p><p class="para4"><span class="span3">Global variables are a bad idea and you should never use them. But if you have to use a global variable, declare them here and be sure to give them a default value. Seriously, </span><span class="span9">don&apos;t use global variables</span><span class="span3">.</span></p><p class="para11"><span class="span19">6. Function prototypes</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">void usage(char *progname, int opt);</span></p><p class="para7"><span class="span6">int  do_the_needful(options_t *options);</span></p><p class="para4"><span class="span3">As you write functions, adding them after the </span><span class="span10">main()</span><span class="span3"> function and not before, include the function prototypes here. Early C compilers used a single-pass strategy, which meant that every symbol (variable or function name) you used in your program had to be declared before you used it. Modern compilers are nearly all multi-pass compilers that build a complete symbol table before generating code, so using function prototypes is not strictly required. However, you sometimes don&apos;t get to choose what compiler is used on your code, so write the function prototypes and drive on.</span></p><p class="para4"><span class="span3">As a matter of course, I always include a </span><span class="span10">usage()</span><span class="span3"> function that </span><span class="span10">main()</span><span class="span3"> calls when it doesn&apos;t understand something you passed in from the command line.</span></p><p class="para11"><span class="span19">7. Command line parsing</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">int main(int argc, char *argv[]) {</span></p><p class="para6"><span class="span6">    int opt;</span></p><p class="para6"><span class="span6">    options_t options = { 0, 0x0, stdin, stdout };</span></p><p class="para6"><span class="span6">    opterr = 0;</span></p><p class="para6"><span class="span6">    while ((opt = getopt(argc, argv, OPTSTR)) != EOF) </span></p><p class="para6"><span class="span6">       switch(opt) {</span></p><p class="para6"><span class="span6">           case &apos;i&apos;:</span></p><p class="para6"><span class="span6">              if (!(options.input = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(optarg, &quot;r&quot;)) ){</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_FOPEN_INPUT);</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">                 /* NOTREACHED */</span></p><p class="para6"><span class="span6">              }</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;o&apos;:</span></p><p class="para6"><span class="span6">              if (!(options.output = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(optarg, &quot;w&quot;)) ){</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_FOPEN_OUTPUT);</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">                 /* NOTREACHED */</span></p><p class="para6"><span class="span6">              }    </span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">              </span></p><p class="para6"><span class="span6">           case &apos;f&apos;:</span></p><p class="para6"><span class="span6">              options.flags = (uint32_t )</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/strtoul.html"><span class="span7">strtoul</span></a><span class="span6">(optarg, NULL, 16);</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;v&apos;:</span></p><p class="para6"><span class="span6">              options.verbose += 1;</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;h&apos;:</span></p><p class="para6"><span class="span6">           default:</span></p><p class="para6"><span class="span6">              usage(basename(argv[0]), opt);</span></p><p class="para6"><span class="span6">              /* NOTREACHED */</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">       }</span></p><p class="para6"><span class="span6">    if (do_the_needful(&amp;options) != EXIT_SUCCESS) {</span></p><p class="para6"><span class="span6">       </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_DO_THE_NEEDFUL);</span></p><p class="para6"><span class="span6">       </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">       /* NOTREACHED */</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">    return EXIT_SUCCESS;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">OK, that&apos;s a lot. The purpose of the </span><span class="span10">main()</span><span class="span3"> function is to collect the arguments that the user provides, perform minimal input validation, and then pass the collected arguments to functions that will use them. This example declares an </span><span class="span10">options</span><span class="span3"> variable initialized with default values and parse the command line, updating </span><span class="span10">options</span><span class="span3"> as necessary.</span></p><p class="para4"><span class="span3">The guts of this </span><span class="span10">main()</span><span class="span3"> function is a </span><span class="span10">while</span><span class="span3"> loop that uses </span><span class="span10">getopt()</span><span class="span3"> to step through </span><span class="span10">argv</span><span class="span3"> looking for command line options and their arguments (if any). The </span><span class="span10">OPTSTR</span><span class="span3"> </span><span class="span10">#define</span><span class="span3"> earlier in the file is the template that drives </span><span class="span10">getopt()</span><span class="span3">&apos;s behavior. The </span><span class="span10">opt</span><span class="span3"> variable takes on the character value of any command line options found by </span><span class="span10">getopt()</span><span class="span3">, and the program&apos;s response to the detection of the command line option happens in the </span><span class="span10">switch</span><span class="span3"> statement.</span></p><p class="para4"><span class="span3">Those of you paying attention will now be questioning why </span><span class="span10">opt</span><span class="span3"> is declared as a 32-bit </span><span class="span10">int</span><span class="span3"> but is expected to take on an 8-bit </span><span class="span10">char</span><span class="span3">? It turns out that </span><span class="span10">getopt()</span><span class="span3"> returns an </span><span class="span10">int</span><span class="span3"> that takes on a negative value when it gets to the end of </span><span class="span10">argv</span><span class="span3">, which I check against </span><span class="span10">EOF</span><span class="span3"> (the </span><span class="span9">End of File</span><span class="span3"> marker). A </span><span class="span10">char</span><span class="span3"> is a signed quantity, but I like matching variables to their function return values.</span></p><p class="para4"><span class="span3">When a known command line option is detected, option-specific behavior happens. Some options have an argument, specified in </span><span class="span10">OPTSTR</span><span class="span3"> with a trailing colon. When an option has an argument, the next string in </span><span class="span10">argv</span><span class="span3"> is available to the program via the externally defined variable </span><span class="span10">optarg</span><span class="span3">. I use </span><span class="span10">optarg</span><span class="span3"> to open files for reading and writing or converting a command line argument from a string to an integer value.</span></p><p class="para4"><span class="span3">There are a couple of points for style here:</span></p><p class="para8"><span class="span3">Initialize </span><span class="span10">opterr</span><span class="span3"> to 0, which disables </span><span class="span10">getopt</span><span class="span3"> from emiting a </span><span class="span10">?</span><span class="span3">. </span></p><p class="para8"><span class="span3">Use </span><span class="span10">exit(EXIT_FAILURE);</span><span class="span3"> or </span><span class="span10">exit(EXIT_SUCCESS);</span><span class="span3"> in the middle of </span><span class="span10">main()</span><span class="span3">. </span></p><p class="para8"><span class="span10">/* NOTREACHED */</span><span class="span3"> is a lint directive that I like. </span></p><p class="para8"><span class="span3">Use </span><span class="span10">return EXIT_SUCCESS;</span><span class="span3"> at the end of functions that return </span><span class="span10">int</span><span class="span3">. </span></p><p class="para4"><span class="span3">Explicitly cast implicit type conversions. </span></p><p class="para4"><span class="span3">The command line signature for this program, were </span><span class="span3">it </span><span class="span3">compiled, </span><span class="span3">lo</span><span class="span3">ok</span><span class="span3">s </span><span class="span3">something like this:</span></p><p class="para6"><span class="span6">$ ./a.out -h</span></p><p class="para7"><span class="span6">a.out [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]</span></p><p class="para4"><span class="span3">In fact, that&apos;s what </span><span class="span10">usage()</span><span class="span3"> emit</span><span class="span3">s</span><span class="span3"> to </span><span class="span10">stderr</span><span class="span3"> once compiled.</span></p><p class="para11"><span class="span19">8. Function declarations</span></p><p class="para6"><span class="span6">/* main.c */</span></p><p class="para6"><span class="span6">&lt;...&gt;</span></p><p class="para6"><span class="span6">void usage(char *progname, int opt) {</span></p><p class="para6"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, USAGE_FMT, progname?progname:DEFAULT_PROGNAME);</span></p><p class="para6"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">   /* NOTREACHED */</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">int do_the_needful(options_t *options) {</span></p><p class="para6"><span class="span6">   if (!options) {</span></p><p class="para6"><span class="span6">     errno = EINVAL;</span></p><p class="para6"><span class="span6">     return EXIT_FAILURE;</span></p><p class="para6"><span class="span6">   }</span></p><p class="para6"><span class="span6">   if (!options-&gt;input || !options-&gt;output) {</span></p><p class="para6"><span class="span6">     errno = ENOENT;</span></p><p class="para6"><span class="span6">     return EXIT_FAILURE;</span></p><p class="para6"><span class="span6">   }</span></p><p class="para6"><span class="span6"> </span><span class="span6"> /* XXX do needful stuff */</span></p><p class="para6"><span class="span6">   return EXIT_SUCCESS;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Finally, I write functions that aren&apos;t boilerplate. In this example, function </span><span class="span10">do_the_needful()</span><span class="span3"> accepts a pointer to an </span><span class="span10">options_t</span><span class="span3"> structure. I validate that the </span><span class="span10">options</span><span class="span3"> pointer is not </span><span class="span10">NULL</span><span class="span3"> and then go on to validate the </span><span class="span10">input</span><span class="span3"> and </span><span class="span10">output</span><span class="span3"> structure members. </span><span class="span10">EXIT_FAILURE</span><span class="span3"> returns if either test fails and, by setting the external global variable </span><span class="span10">errno</span><span class="span3"> to a conventional error code, I signal to the caller a general reason. The convenience function </span><span class="span10">perror()</span><span class="span3"> can be used by the caller to emit human-readable-ish error messages based on the value of </span><span class="span10">errno</span><span class="span3">.</span></p><p class="para4"><span class="span3">Functions should almost always validate their input in some way. If full validation is expensive, try to do it once and treat the validated data as immutable. The </span><span class="span10">usage()</span><span class="span3"> function validates the </span><span class="span10">progname</span><span class="span3"> argument using a conditional assignment in the </span><span class="span10">fprintf()</span><span class="span3"> call. The </span><span class="span10">usage()</span><span class="span3"> function is going to exit anyway, so I don&apos;t bother setting </span><span class="span10">errno</span><span class="span3"> or making a big stink about using a correct program name.</span></p><p class="para4"><span class="span3">The big class of errors I am trying to avoid here is de-referencing a </span><span class="span10">NULL</span><span class="span3"> pointer. This will cause the operating system to send a special signal to my process called </span><span class="span10">SYSSEGV</span><span class="span3">, which results in unavoidable death. The last thing users want to see is a crash due to </span><span class="span10">SYSSEGV</span><span class="span3">. It&apos;s much better to catch a </span><span class="span10">NULL</span><span class="span3"> pointer in order to emit better error messages and shut down the program gracefully.</span></p><p class="para4"><span class="span3">Some people complain about having multiple </span><span class="span10">return</span><span class="span3"> statements in a function body. They make arguments about &quot;continuity of control flow&quot; and other stuff. Honestly, if something goes wrong in the middle of a function, it&apos;s a good time to return an error condition. Writing a ton of nested </span><span class="span10">if</span><span class="span3"> statements to just have one return is never a &quot;good idea.&quot;™</span></p><p class="para4"><span class="span3">Finally, if you write a function that takes four or more arguments, consider bundling them in a structure and passing a pointer to the structure. This makes the function signatures simpler, making them easier to remember and not screw up when they&apos;re called later. It also makes calling the function slightly faster, since fewer things need to be copied into the function&apos;s stack frame. In practice, this will only become a consideration if the function is called millions or billions of times. Don&apos;t worry about it if that doesn&apos;t make sense.</span></p><p class="para5"><span class="span5">Wait, you said no comments!?!!</span></p><p class="para4"><span class="span3">In the </span><span class="span10">do_the_needful()</span><span class="span3"> function, I wrote a specific type of comment that is designed to be a placeholder rather than documenting the code:</span></p><p class="para7"><span class="span6">/* XXX do needful stuff */</span></p><p class="para4"><span class="span3">When you are in the zone, sometimes you don&apos;t want to stop and write some particularly gnarly bit of code. You&apos;ll come back and do it later, just not now. That&apos;s where I&apos;ll leave myself a little breadcrumb. I insert a comment with a </span><span class="span10">XXX</span><span class="span3"> prefix and a short remark describing what needs to be done. Later on, when I have more time, I&apos;ll grep through source looking for </span><span class="span10">XXX</span><span class="span3">. It doesn&apos;t matter what you use, just make sure it&apos;s not likely to show up in your codebase in another context, as a function name or variable, for instance.</span></p><p class="para5"><span class="span5">Putting it all together</span></p><p class="para4"><span class="span3">OK, this program </span><span class="span9">still</span><span class="span3"> does almost nothing when you compile and run it. But now you have a solid skeleton to build your own command line parsing C programs.</span></p><p class="para6"><span class="span6">/* main.c - the complete listing */</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;stdlib.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;unistd.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;libgen.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;errno.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;string.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;getopt.h&gt;</span></p><p class="para6"><span class="span6">#define OPTSTR &quot;vi:o:f:h&quot;</span></p><p class="para6"><span class="span6">#define USAGE_FMT  &quot;%s [-v] [-f hexflag] [-i inputfile] [-o outputfile] [-h]&quot;</span></p><p class="para6"><span class="span6">#define ERR_FOPEN_INPUT  &quot;fopen(input, r)&quot;</span></p><p class="para6"><span class="span6">#define ERR_FOPEN_OUTPUT &quot;fopen(output, w)&quot;</span></p><p class="para6"><span class="span6">#define ERR_DO_THE_NEEDFUL &quot;do_the_needful blew up&quot;</span></p><p class="para6"><span class="span6">#define DEFAULT_PROGNAME &quot;george&quot;</span></p><p class="para6"><span class="span6">extern int errno;</span></p><p class="para6"><span class="span6">extern char *optarg;</span></p><p class="para6"><span class="span6">extern int opterr, optind;</span></p><p class="para6"><span class="span6">typedef struct {</span></p><p class="para6"><span class="span6">  int           verbose;</span></p><p class="para6"><span class="span6">  uint32_t      flags;</span></p><p class="para6"><span class="span6">  FILE         *input;</span></p><p class="para6"><span class="span6">  FILE         *output;</span></p><p class="para6"><span class="span6">} options_t;</span></p><p class="para6"><span class="span6">int dumb_global_variable = -11;</span></p><p class="para6"><span class="span6">void usage(char *progname, int opt);</span></p><p class="para6"><span class="span6">int  do_the_needful(options_t *options);</span></p><p class="para6"><span class="span6">int main(int argc, char *argv[]) {</span></p><p class="para6"><span class="span6">    int opt;</span></p><p class="para6"><span class="span6">    options_t options = { 0, 0x0, stdin, stdout };</span></p><p class="para6"><span class="span6">    opterr = 0;</span></p><p class="para6"><span class="span6">    while ((opt = getopt(argc, argv, OPTSTR)) != EOF) </span></p><p class="para6"><span class="span6">       switch(opt) {</span></p><p class="para6"><span class="span6">           case &apos;i&apos;:</span></p><p class="para6"><span class="span6">              if (!(options.input = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(optarg, &quot;r&quot;)) ){</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_FOPEN_INPUT);</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">                 /* NOTREACHED */</span></p><p class="para6"><span class="span6">              }</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;o&apos;:</span></p><p class="para6"><span class="span6">              if (!(options.output = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(optarg, &quot;w&quot;)) ){</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_FOPEN_OUTPUT);</span></p><p class="para6"><span class="span6">                 </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">                 /* NOTREACHED */</span></p><p class="para6"><span class="span6">              }    </span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">              </span></p><p class="para6"><span class="span6">           case &apos;f&apos;:</span></p><p class="para6"><span class="span6">              options.flags = (uint32_t )</span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/strtoul.html"><span class="span7">strtoul</span></a><span class="span6">(optarg, NULL, 16);</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;v&apos;:</span></p><p class="para6"><span class="span6">              options.verbose += 1;</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">           case &apos;h&apos;:</span></p><p class="para6"><span class="span6">           default:</span></p><p class="para6"><span class="span6">              usage(basename(argv[0]), opt);</span></p><p class="para6"><span class="span6">              /* NOTREACHED */</span></p><p class="para6"><span class="span6">              break;</span></p><p class="para6"><span class="span6">       }</span></p><p class="para6"><span class="span6">    if (do_the_needful(&amp;options) != EXIT_SUCCESS) {</span></p><p class="para6"><span class="span6">       </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="span7">perror</span></a><span class="span6">(ERR_DO_THE_NEEDFUL);</span></p><p class="para6"><span class="span6">       </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">       /* NOTREACHED */</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">    return EXIT_SUCCESS;</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">void usage(char *progname, int opt) {</span></p><p class="para6"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="span7">fprintf</span></a><span class="span6">(stderr, USAGE_FMT, progname?progname:DEFAULT_PROGNAME);</span></p><p class="para6"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="span7">exit</span></a><span class="span6">(EXIT_FAILURE);</span></p><p class="para6"><span class="span6">   /* NOTREACHED */</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">int do_the_needful(options_t *options) {</span></p><p class="para6"><span class="span6">   if (!options) {</span></p><p class="para6"><span class="span6">     errno = EINVAL;</span></p><p class="para6"><span class="span6">     return EXIT_FAILURE;</span></p><p class="para6"><span class="span6">   }</span></p><p class="para6"><span class="span6">   if (!options-&gt;input || !options-&gt;output) {</span></p><p class="para6"><span class="span6">     errno = ENOENT;</span></p><p class="para6"><span class="span6">     return EXIT_FAILURE;</span></p><p class="para6"><span class="span6">   }</span></p><p class="para6"><span class="span6">   /* XXX do needful stuff */</span></p><p class="para6"><span class="span6">   return EXIT_SUCCESS;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Now you&apos;re ready to write C that will be easier to maintain.</span></p><p class="para4"> </p></body></html>
<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">T</span><span class="span2">he basics of programming with C</span></p><p class="para4"><span class="span3">By </span><span class="span3">Seth Kenlon</span></p><p class="para4"><span class="span3">In 1972, Dennis Ritchie was at Bell Labs, where a few years earlier, he and his fellow team members invented Unix. After creating an enduring OS (still in use today), he needed a good way to program those Unix computers so that they could perform new tasks. It seems strange now, but at the time, there were relatively few programming languages; Fortran, Lisp, </span><a href="https://opensource.com/article/20/6/algol68"><span class="span4">Algol</span></a><span class="span3">, and B were popular but insufficient for what the Bell Labs researchers wanted to do. Demonstrating a trait that would become known as a primary characteristic of programmers, Dennis Ritchie created his own solution. He called it C, and nearly 50 years later, it&apos;s still in widespread use.</span></p><p class="para5"><span class="span5">Why you should learn C</span></p><p class="para4"><span class="span3">Today, there are many languages that provide programmers more features than C. The most obvious one is C++, a rather blatantly named language that built upon C to create a nice object-oriented language. There are many others, though, and there&apos;s a good reason they exist. Computers are good at consistent repetition, so anything predictable enough to be built into a language means less work for programmers. Why spend two lines recasting an </span><span class="span8">int</span><span class="span3"> to a </span><span class="span8">long</span><span class="span3"> in C when one line of C++ (</span><span class="span8">long x = long(n);</span><span class="span3">) can do the same?</span></p><p class="para4"><span class="span3">And yet C is still useful today.</span></p><p class="para4"><span class="span3">First of all, C is a fairly minimal and straightforward language. There aren&apos;t very advanced concepts beyond the basics of programming, largely because C is literally one of the foundations of modern programming languages. For instance, C features arrays, but it doesn&apos;t offer a dictionary (unless you write it yourself). When you learn C, you learn the building blocks of programming that can help you recognize the improved and elaborate designs of recent languages.</span></p><p class="para5"><span class="span5">Programming and development</span></p><p class="para4"><span class="span3">Because C is a minimal language, your applications are likely to get a boost in performance that they wouldn&apos;t see with many other languages. It&apos;s easy to get caught up in the race to the bottom when you&apos;re thinking about how fast your code executes, so it&apos;s important to ask whether you </span><span class="span9">need</span><span class="span3"> more speed for a specific task. And with C, you have less to obsess over in each line of code, compared to, say, Python or Java. C is fast. There&apos;s a good reason the Linux kernel is written in C.</span></p><p class="para4"><span class="span3">Finally, C is easy to get started with, especially if you&apos;re running Linux. You can already run C code because Linux systems include the GNU C library (</span><span class="span8">glibc</span><span class="span3">). To write and build it, all you need to do is install a compiler, open a text editor, and start coding.</span></p><p class="para5"><span class="span5">Getting started with C</span></p><p class="para4"><span class="span3">If you&apos;re running Linux, you can install a C compiler using your package manager. On Fedora or RHEL:</span></p><p class="para7"><span class="span6">$ sudo dnf install gcc</span></p><p class="para4"><span class="span3">On Debian and similar:</span></p><p class="para7"><span class="span6">$ sudo apt install build-essential </span></p><p class="para4"><span class="span3">On macOS, you can </span><a href="https://opensource.com/article/20/6/homebrew-mac"><span class="span4">install Homebrew</span></a><span class="span3"> and use it to install </span><a href="https://gcc.gnu.org/"><span class="span4">GCC</span></a><span class="span3">:</span></p><p class="para7"><span class="span6">$ brew install gcc</span></p><p class="para4"><span class="span3">On Windows, you can install a minimal set of GNU utilities, GCC included, with </span><a href="https://opensource.com/article/20/8/gnu-windows-mingw"><span class="span4">MinGW</span></a><span class="span3">.</span></p><p class="para4"><span class="span3">Verify you&apos;ve installed GCC on Linux or macOS:</span></p><p class="para6"><span class="span6">$ gcc --version</span></p><p class="para6"><span class="span6">gcc (GCC) x.y.z</span></p><p class="para7"><span class="span6">Copyright (C) 20XX Free Software Foundation, Inc.</span></p><p class="para4"><span class="span3">On Windows, provide the full path to the EXE file:</span></p><p class="para6"><span class="span6">PS&gt; C:\MinGW\bin\gcc.exe --version</span></p><p class="para6"><span class="span6">gcc.exe (MinGW.org GCC Build-2) x.y.z</span></p><p class="para7"><span class="span6">Copyright (C) 20XX Free Software Foundation, Inc.</span></p><p class="para5"><span class="span5">C syntax</span></p><p class="para4"><span class="span3">C isn&apos;t a scripting language. It&apos;s compiled, meaning that it gets processed by a C compiler to produce a binary executable file. This is different from a scripting language like </span><a href="https://opensource.com/resources/what-bash"><span class="span4">Bash</span></a><span class="span3"> or a hybrid language like </span><a href="https://opensource.com/resources/python"><span class="span4">Python</span></a><span class="span3">.</span></p><p class="para4"><span class="span3">In C, you create </span><span class="span9">functions</span><span class="span3"> to carry out your desired task. A function named </span><span class="span8">main</span><span class="span3"> is executed by default.</span></p><p class="para4"><span class="span3">Here&apos;s a simple &quot;hello world&quot; program written in C:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"> </p><p class="para6"><span class="span6">int main() {</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;Hello world&quot;);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">The first line includes a </span><span class="span9">header file</span><span class="span3">, essentially free and very low-level C code that you can reuse in your own programs, called </span><span class="span8">stdio.h</span><span class="span3"> (standard input and output). A function called </span><span class="span8">main</span><span class="span3"> is created and populated with a rudimentary print statement. Save this text to a file called </span><span class="span8">hello.c</span><span class="span3">, then compile it with GCC:</span></p><p class="para7"><span class="span6">$ gcc hello.c --output hello</span></p><p class="para4"><span class="span3">Try running your C program:</span></p><p class="para6"><span class="span6">$ ./hello</span></p><p class="para7"><span class="span6">Hello world$</span></p><p class="para5"><span class="span5">Return values</span></p><p class="para4"><span class="span3">It&apos;s part of the Unix philosophy that a function &quot;returns&quot; something to you after it executes: nothing upon success and something else (an error message, for example) upon failure. These return codes are often represented with numbers (integers, to be precise): 0 represents nothing, and any number higher than 0 represents some non-successful state.</span></p><p class="para4"><span class="span3">There&apos;s a good reason Unix and Linux are designed to expect silence upon success. It&apos;s so that you can always plan for success by assuming no errors nor warnings will get in your way when executing a series of commands. Similarly, functions in C expect no errors by design.</span></p><p class="para4"><span class="span3">You can see this for yourself with one small modification to make your program appear to fail:</span></p><p class="para6"><span class="span6">include &lt;stdio.h&gt;</span></p><p class="para6"> </p><p class="para6"><span class="span6">int main() {</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;Hello world&quot;);</span></p><p class="para6"><span class="span6">  return 1;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Compile it:</span></p><p class="para7"><span class="span6">$ gcc hello.c --output failer</span></p><p class="para4"><span class="span3">Now run it using a built-in Linux test for success. The </span><span class="span8">&amp;&amp;</span><span class="span3"> operator executes the second half of a command only upon success. For example:</span></p><p class="para6"><span class="span6">$ echo &quot;success&quot; &amp;&amp; echo &quot;it worked&quot;</span></p><p class="para6"><span class="span6">success</span></p><p class="para7"><span class="span6">it worked</span></p><p class="para4"><span class="span3">The </span><span class="span8">||</span><span class="span3"> test executes the second half of a command upon </span><span class="span9">failure</span><span class="span3">.</span></p><p class="para6"><span class="span6">$ ls blah || echo &quot;it did not work&quot;</span></p><p class="para6"><span class="span6">ls: cannot access &apos;blah&apos;: No such file or directory</span></p><p class="para7"><span class="span6">it did not work</span></p><p class="para4"><span class="span3">Now try your program, which does </span><span class="span9">not</span><span class="span3"> return 0 upon success; it returns 1 instead:</span></p><p class="para6"><span class="span6">$ ./failer &amp;&amp; echo &quot;it worked&quot;</span></p><p class="para7"><span class="span6">String is: hello</span></p><p class="para4"><span class="span3">The program executed successfully, yet did not trigger the second command.</span></p><p class="para5"><span class="span5">Variables and types</span></p><p class="para4"><span class="span3">In some languages, you can create variables without specifying what </span><span class="span9">type</span><span class="span3"> of data they contain. Those languages have been designed such that the interpreter runs some tests against a variable in an attempt to discover what kind of data it contains. For instance, Python knows that </span><span class="span8">var=1</span><span class="span3"> defines an integer when you create an expression that adds </span><span class="span8">var</span><span class="span3"> to something that is obviously an integer. It similarly knows that the word </span><span class="span8">world</span><span class="span3"> is a string when you concatenate </span><span class="span8">hello</span><span class="span3"> and </span><span class="span8">world</span><span class="span3">.</span></p><p class="para4"><span class="span3">C doesn&apos;t do any of these investigations for you; you must define your variable type. There are several types of variables, including integers (int), characters (char), float, and Boolean.</span></p><p class="para4"><span class="span3">You may also notice there&apos;s no string type. Unlike Python and Java and Lua and many others, C doesn&apos;t have a string type and instead sees strings as an array of characters.</span></p><p class="para4"><span class="span3">Here&apos;s some simple code that establishes a </span><span class="span8">char</span><span class="span3"> array variable, and then prints it to your screen using </span><a href="https://opensource.com/article/20/8/printf"><span class="span4">printf</span></a><span class="span3"> along with a short message:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"> </p><p class="para6"><span class="span6">int main() {</span></p><p class="para6"><span class="span6">   char var[6] = &quot;hello&quot;;</span></p><p class="para7"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;Your string is: %s\r\n&quot;,var);</span></p><p class="para4"><span class="span3">You may notice that this code sample allows six characters for a five-letter word. This is because there&apos;s a hidden terminator at the end of the string, which takes up one byte in the array. You can run the code by compiling and executing it:</span></p><p class="para6"><span class="span6">$ gcc hello.c --output hello</span></p><p class="para6"><span class="span6">$ ./hello</span></p><p class="para7"><span class="span6">hello</span></p><p class="para5"><span class="span5">Functions</span></p><p class="para4"><span class="span3">As with other languages, C functions take optional parameters. You can pass parameters from one function to another by defining the type of data you want a function to accept:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"> </p><p class="para6"><span class="span6">int printmsg(char a[]) {</span></p><p class="para6"><span class="span6">   </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;String is: %s\r\n&quot;,a);</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"> </p><p class="para6"><span class="span6">int main() {</span></p><p class="para6"><span class="span6">   char a[6] = &quot;hello&quot;;</span></p><p class="para6"><span class="span6">   printmsg(a);</span></p><p class="para6"><span class="span6">   return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">The way this code sample breaks one function into two isn&apos;t very useful, but it demonstrates that </span><span class="span8">main</span><span class="span3"> runs by default and how to pass data between functions.</span></p><p class="para5"><span class="span5">Conditionals</span></p><p class="para4"><span class="span3">In real-world programming, you usually want your code to make decisions based on data. This is done with </span><span class="span9">conditional</span><span class="span3"> statements, and the </span><span class="span8">if</span><span class="span3"> statement is one of the most basic of them.</span></p><p class="para4"><span class="span3">To make this example program more dynamic, you can include the </span><span class="span8">string.h</span><span class="span3"> header file, which contains code to examine (as the name implies) strings. Try testing whether the string passed to the </span><span class="span8">printmsg</span><span class="span3"> function is greater than 0 by using the </span><span class="span8">strlen</span><span class="span3"> function from the </span><span class="span8">string.h</span><span class="span3"> file:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;string.h&gt;</span></p><p class="para6"> </p><p class="para6"><span class="span6">int printmsg(char a[]) {</span></p><p class="para6"><span class="span6">  size_t len = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="span7">strlen</span></a><span class="span6">(a);</span></p><p class="para6"><span class="span6">  if ( len &gt; 0) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;String is: %s\r\n&quot;,a);</span></p><p class="para6"><span class="span6">  } }</span></p><p class="para6"> </p><p class="para6"><span class="span6">int main() {</span></p><p class="para6"><span class="span6">   char a[6] = &quot;hello&quot;;</span></p><p class="para6"><span class="span6">   printmsg(a);</span></p><p class="para6"><span class="span6">   return 1; </span></p><p class="para6"><span class="span6">}</span></p><p class="para4"><span class="span3">As implemented in this example, the sample condition will never be untrue because the string provided is always &quot;hello,&quot; the length of which is always greater than 0. The final touch to this humble re-implementation of the </span><span class="span8">echo</span><span class="span3"> command is to accept input from the user.</span></p><p class="para5"><span class="span5">Command arguments</span></p><p class="para4"><span class="span3">The </span><span class="span8">stdio.h</span><span class="span3"> file contains code that provides two arguments each time a program is launched: a count of how many items are contained in the command (</span><span class="span8">argc</span><span class="span3">) and an array containing each item (</span><span class="span8">argv</span><span class="span3">). For example, suppose you issue this imaginary command:</span></p><p class="para7"><span class="span6">$ foo -i bar</span></p><p class="para4"><span class="span3">The </span><span class="span8">argc</span><span class="span3"> is three, and the contents of </span><span class="span8">argv</span><span class="span3"> are:</span></p><p class="para8"><span class="span8">argv[0] = foo</span><span class="span3"> </span></p><p class="para8"><span class="span8">argv[1] = -i</span><span class="span3"> </span></p><p class="para4"><span class="span8">argv[2] = bar</span><span class="span3"> </span></p><p class="para4"><span class="span3">Can you modify the example C program to accept </span><span class="span8">argv[2]</span><span class="span3"> as the string instead of defaulting to </span><span class="span8">hello</span><span class="span3">?</span></p><p class="para5"><span class="span5">Imperative programming</span></p><p class="para4"><span class="span3">C is an imperative programming language. It isn&apos;t object-oriented, and it has no class structure. Using C can teach you a lot about how data is processed and how to better manage the data you generate as your code runs. Use C enough, and you&apos;ll eventually be able to write libraries that other languages, such as Python and Lua, can use.</span></p><p class="para4"><span class="span3">To learn more about C, you need to use it. Look in </span><span class="span8">/usr/include/</span><span class="span3"> for useful C header files, and see what small tasks you can do to make C useful to you.</span></p><p class="para4"> </p></body></html>
<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">Programming on FreeDos: </span><span class="span2">Print a Halloween greeting with ASCII art</span></p><p class="para4"><span class="span3">By Jim Hall</span></p><p class="para4"><span class="span3">Full-color ASCII art used to be quite popular on DOS, which could leverage the extended ASCII character set and its collection of drawing elements. You can add a little visual interest to your next FreeDOS program by adding ASCII art as a cool “welcome” screen or as a colorful “exit” screen with more information about the program.</span></p><p class="para4"><span class="span3">But this style of ASCII art isn’t limited just to FreeDOS applications. You can use the same method in a Linux terminal-mode program. While Linux uses </span><a href="https://opensource.com/article/21/8/ncurses-linux"><span class="span4">ncurses</span></a><span class="span3"> to control the screen instead of DOS’s </span><a href="https://opensource.com/article/21/9/programming-dos-conio"><span class="span4">conio</span></a><span class="span3">, the related concepts apply well to Linux programs. This article looks at how to generate colorful ASCII art from a C program.</span></p><p class="para5"><span class="span5">An ASCII art file</span></p><p class="para4"><span class="span3">You can use a variety of tools to draw your ASCII art. For this example, I used an old DOS application called TheDraw, but you can find modern open source ASCII art programs on Linux, such as </span><a href="https://blocktronics.github.io/moebius/"><span class="span4">Moebius</span></a><span class="span3"> (Apache license) or </span><a href="https://github.com/blocktronics/pablodraw"><span class="span4">PabloDraw</span></a><span class="span3"> (MIT license). It doesn’t matter what tool you use as long as you know what the saved data looks like.</span></p><p class="para4"><span class="span3">Here’s part of a sample ASCII art file, saved as C source code. Note that the code snippet defines a few values: </span><span class="span8">IMAGEDATA_WIDTH</span><span class="span3"> and </span><span class="span8">IMAGEDATA_DEPTH</span><span class="span3"> define the number of columns and rows on the screen. In this case, it’s an 80x25 ASCII art “image.” </span><span class="span8">IMAGEDATA_LENGTH</span><span class="span3"> defines the number of entries in the </span><span class="span8">IMAGEDATA</span><span class="span3"> array. Each character in the ASCII art screen can be represented by two bytes of data: The character to display and a color attribute containing both the foreground and background colors for the character. For an 80x25 screen, where each character is paired with an attribute, the array contains 4000 entries (that’s 80 * 25 * 2 = 4000).</span></p><p class="para6"><span class="span6">#define IMAGEDATA_WIDTH 80</span></p><p class="para6"><span class="span6">#define IMAGEDATA_DEPTH 25</span></p><p class="para6"><span class="span6">#define IMAGEDATA_LENGTH 4000</span></p><p class="para6"><span class="span6">unsigned char IMAGEDATA [] = {</span></p><p class="para6"><span class="span6">    &apos;.&apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,</span></p><p class="para6"><span class="span6">    &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos;.&apos;, 0x0F,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,</span></p><p class="para6"><span class="span6">    &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos;.&apos;, 0x0F,</span></p><p class="para6"><span class="span6">    &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,</span></p><p class="para7"><span class="span6">    &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,  &apos; &apos;, 0x08,</span></p><p class="para4"><span class="span3">and so on for the rest of the array.</span></p><p class="para4"><span class="span3">To display this ASCII art to the screen, you need to write a small program to read the array and print each character with the right colors.</span></p><p class="para5"><span class="span5">Setting a color attribute</span></p><p class="para4"><span class="span3">The color attribute in this ASCII art file defines both the background and foreground color in a single byte, represented by hexadecimal values like </span><span class="span8">0x08</span><span class="span3"> or </span><span class="span8">0x6E</span><span class="span3">. Hexadecimal turns out to be a compact way to express a color “pair” like this.</span></p><p class="para4"><span class="span3">Character mode systems like ncurses on Linux or conio on DOS </span><a href="https://opensource.com/article/21/6/freedos-sixteen-colors"><span class="span4">can display only sixteen colors</span></a><span class="span3">. That’s sixteen possible text colors and eight background colors. Counting sixteen values (from 0 to 15) in binary requires only four bits:</span></p><p class="para4"><span class="span8">1111</span><span class="span3"> is 16 in binary </span></p><p class="para4"><span class="span3">And conveniently, hexadecimal can represent 0 to 15 with a single character: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F. So the value </span><span class="span8">F</span><span class="span3"> in hexadecimal is the number 15, or </span><span class="span8">1111</span><span class="span3"> in binary.</span></p><p class="para4"><span class="span3">With color pairs, you can encode both the background and foreground colors in a single byte of eight bits. That’s four bits for the text color (0 to 15 or 0 to F in hexadecimal) and three bits for the background color (0 to 7 or 0 to E in hexadecimal). The leftover bit in the byte is not used here, so we can ignore it.</span></p><p class="para4"><span class="span3">To convert the color pair or attribute into color values that your program can use, you’ll need to </span><a href="https://opensource.com/article/21/8/binary-bit-fields-masks"><span class="span4">use a bit mask</span></a><span class="span3"> to specify only the bits used for the text color or background color. Using the OpenWatcom C Compiler on FreeDOS, you can write this function to set the colors appropriately from the color attribute:</span></p><p class="para6"><span class="span6">void</span></p><p class="para6"><span class="span6">textattr(int newattr)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  _settextcolor(newattr &amp; 15);         /* 0000xxxx */</span></p><p class="para6"><span class="span6">  _setbkcolor((newattr &gt;&gt; 4) &amp; 7);     /* 0xxx0000 */</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">The </span><span class="span8">_settextcolor</span><span class="span3"> function sets just the text color, and the </span><span class="span8">_setbkcolor</span><span class="span3"> function sets the background color. Both are defined in </span><span class="span8">graph.h</span><span class="span3">. Note that because the color attribute included both the background color and the foreground color in a single byte value, the </span><span class="span8">textattr</span><span class="span3"> function uses </span><span class="span8">&amp;</span><span class="span3"> (binary AND) to set a bit mask that isolates only the last four bits in the attribute. That’s where the color pair stores the values 0 to 15 for the foreground color.</span></p><p class="para4"><span class="span3">To get the background color, the function first performs a bit shift to “push” the bits to the right. This puts the “upper” bits into the “lower” bit range, so any bits like </span><span class="span8">0xxx0000</span><span class="span3"> become </span><span class="span8">00000xxx</span><span class="span3"> instead. We can use another bit mask with 7 (binary </span><span class="span8">0111</span><span class="span3">) to pick out the background color value.</span></p><p class="para5"><span class="span5">Displaying ASCII art</span></p><p class="para4"><span class="span3">The </span><span class="span8">IMAGEDATA</span><span class="span3"> array contains the entire ASCII art screen and the color values for each character. To display the ASCII art to the screen, your program needs to scan the array, set the color attribute, then show the screen one character at a time.</span></p><p class="para4"><span class="span3">Let’s leave room at the bottom of the screen for a separate message or prompt to the user. That means instead of displaying all 25 lines of an 80-column ASCII screen, I only want to show the first 24 lines.</span></p><p class="para6"><span class="span6">  /* print one line less than the 80x25 that&apos;s in there:</span></p><p class="para6"><span class="span6">     80 x 24 x 2 = 3840 */</span></p><p class="para6"><span class="span6">  for (pos = 0; pos &lt; 3840; pos += 2) {</span></p><p class="para6"><span class="span6">...</span></p><p class="para7"><span class="span6">  }</span></p><p class="para4"><span class="span3">Inside the </span><span class="span8">for</span><span class="span3"> loop, we need to set the colors, then print the character. The OpenWatcom C Compiler provides a function </span><span class="span8">_outtext</span><span class="span3"> to display text with the current color values. However, this requires passing a string and would be inefficient if we need to process each character one at a time, in case each character on a line requires a different color.</span></p><p class="para4"><span class="span3">Instead, OpenWatcom has a similar function called </span><span class="span8">_outmem</span><span class="span3"> that allows you to indicate how many characters to display. For one character at a time, we can provide a pointer to a character value in the </span><span class="span8">IMAGEDATA</span><span class="span3"> array and tell </span><span class="span8">_outtext</span><span class="span3"> to show just one character. That will display the character using the current color attributes, which is what we need.</span></p><p class="para6"><span class="span6">  for (pos = 0; pos &lt; 3840; pos += 2) {</span></p><p class="para6"><span class="span6">    ch = &amp;IMAGEDATA[pos];              /* pointer assignment */</span></p><p class="para6"><span class="span6">    attr = IMAGEDATA[pos + 1];</span></p><p class="para6"><span class="span6"> </span></p><p class="para6"><span class="span6">    textattr(attr);</span></p><p class="para6"><span class="span6">    _outmem(ch, 1);</span></p><p class="para7"><span class="span6">  }</span></p><p class="para4"><span class="span3">This updated </span><span class="span8">for</span><span class="span3"> loop sets the character </span><span class="span8">ch</span><span class="span3"> by assigning a pointer into the </span><span class="span8">IMAGEDATA</span><span class="span3"> array. Next, the loop sets the text attributes, and then displays the character with </span><span class="span8">_outmem</span><span class="span3">.</span></p><p class="para5"><span class="span5">Putting it all together</span></p><p class="para4"><span class="span3">With the </span><span class="span8">textattr</span><span class="span3"> function and the </span><span class="span8">for</span><span class="span3"> loop to process the array, we can write a full program to display the contents of an ASCII art file. For this example, save the ASCII art as </span><span class="span8">imgdata.inc</span><span class="span3"> and include it in the source file with an </span><span class="span8">#include</span><span class="span3"> statement.</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;conio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;graph.h&gt;</span></p><p class="para6"><span class="span6">#include &quot;imgdata.inc&quot;</span></p><p class="para6"><span class="span6">void</span></p><p class="para6"><span class="span6">textattr(int newattr)</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  _settextcolor(newattr &amp; 15);         /* 0000xxxx */</span></p><p class="para6"><span class="span6">  _setbkcolor((newattr &gt;&gt; 4) &amp; 7);     /* 0xxx0000 */</span></p><p class="para6"><span class="span6">}</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  char *ch;</span></p><p class="para6"><span class="span6">  int attr;</span></p><p class="para6"><span class="span6">  int pos;</span></p><p class="para6"><span class="span6">  if (_setvideomode(_TEXTC80) == 0) {</span></p><p class="para6"><span class="span6">    fputs(&quot;Error setting video mode&quot;, stderr);</span></p><p class="para6"><span class="span6">    return 1;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* draw the array */</span></p><p class="para6"><span class="span6">  _settextposition(1, 1);              /* top left */</span></p><p class="para6"><span class="span6">  /* print one line less than the 80x25 that&apos;s in there:</span></p><p class="para6"><span class="span6">     80 x 24 x 2 = 3840 */</span></p><p class="para6"> </p><p class="para6"><span class="span6">  for (pos = 0; pos &lt; 3840; pos += 2) {</span></p><p class="para6"><span class="span6">    ch = &amp;IMAGEDATA[pos];              /* pointer assignment */</span></p><p class="para6"><span class="span6">    attr = IMAGEDATA[pos + 1];</span></p><p class="para6"><span class="span6">    textattr(attr);</span></p><p class="para6"><span class="span6">    _outmem(ch, 1);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  _settextposition(25, 1);             /* bottom left */</span></p><p class="para6"><span class="span6">  textattr(0x0f);</span></p><p class="para6"><span class="span6">  _outtext(&quot;Press any key to quit&quot;);</span></p><p class="para6"><span class="span6">  getch();</span></p><p class="para6"><span class="span6">  textattr(0x00);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Compile the program using the OpenWatcom C Compiler on FreeDOS, and you’ll get a new program that displays this holiday message:</span></p><p class="para4"><img alt="OEBPS/images/image0007.png" class="frame5" src="../images/image0007.png"/><span class="span3"> </span> </p><p class="para4"> </p><p class="para4"> </p></body></html>
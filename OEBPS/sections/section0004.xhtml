<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/></head><body class="body0" xmlns:epub="http://www.idpf.org/2007/ops"><p class="para3"><span class="span2">5 common bugs in C programming and how to fix them</span></p><p class="para4"><span class="span3">By Jim Hall</span></p><p class="para4"><span class="span3">Even the best programmers can create programming bugs. Depending on what your program does, these bugs could introduce security vulnerabilities, cause the program to crash, or create unexpected behavior.</span></p><p class="para4"><span class="span3">The C programming language sometimes gets a bad reputation because it is not memory safe like more recent programming languages, including Rust. But with a little extra code, you can avoid the most common and most serious C programming bugs. Here are five bugs that can break your application and how you can avoid them:</span></p><p class="para5"><span class="span5">1. Uninitialized variables</span></p><p class="para4"><span class="span3">When the program starts up, the system will assign it a block of memory that the program uses to store data. That means your variables will get whatever random value was in memory when the program started.</span></p><p class="para4"><span class="span3">Some environments will intentionally &quot;zero out&quot; the memory as the program starts up, so every variable starts with a zero value. And it can be tempting to assume in your programs that all variables will begin at zero. However, the C programming specification says that the system does not initialize variables.</span></p><p class="para4"><span class="span3">Consider a sample program that uses a few variables and two arrays:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;stdlib.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"> </p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int i, j, k;</span></p><p class="para6"><span class="span6">  int numbers[5];</span></p><p class="para6"><span class="span6">  int *array;</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;These variables are not initialized:&quot;);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  i = %d\n&quot;, i);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  j = %d\n&quot;, j);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  k = %d\n&quot;, k);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;This array is not initialized:&quot;);</span></p><p class="para6"><span class="span6">  for (i = 0; i &lt; 5; i++) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  numbers[%d] = %d\n&quot;, i, numbers[i]);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;malloc an array ...&quot;);</span></p><p class="para6"><span class="span6">  array = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="span7">malloc</span></a><span class="span6">(sizeof(int) * 5);</span></p><p class="para6"><span class="span6">  if (array) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;This malloc&apos;ed array is not initialized:&quot;);</span></p><p class="para6"><span class="span6">    for (i = 0; i &lt; 5; i++) {</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  array[%d] = %d\n&quot;, i, array[i]);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="span7">free</span></a><span class="span6">(array);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Ok&quot;);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">The program does not initialize the variables, so they start with whatever values the system had in memory at the time. Compiling and running this program on my Linux system, you&apos;ll see that some variables happen to have &quot;zero&quot; values, but others do not:</span></p><p class="para6"><span class="span6">These variables are not initialized:</span></p><p class="para6"><span class="span6">  i = 0</span></p><p class="para6"><span class="span6">  j = 0</span></p><p class="para6"><span class="span6">  k = 32766</span></p><p class="para6"><span class="span6">This array is not initialized:</span></p><p class="para6"><span class="span6">  numbers[0] = 0</span></p><p class="para6"><span class="span6">  numbers[1] = 0</span></p><p class="para6"><span class="span6">  numbers[2] = 4199024</span></p><p class="para6"><span class="span6">  numbers[3] = 0</span></p><p class="para6"><span class="span6">  numbers[4] = 0</span></p><p class="para6"><span class="span6">malloc an array ...</span></p><p class="para6"><span class="span6">This malloc&apos;ed array is not initialized:</span></p><p class="para6"><span class="span6">  array[0] = 0</span></p><p class="para6"><span class="span6">  array[1] = 0</span></p><p class="para6"><span class="span6">  array[2] = 0</span></p><p class="para6"><span class="span6">  array[3] = 0</span></p><p class="para6"><span class="span6">  array[4] = 0</span></p><p class="para7"><span class="span6">Ok</span></p><p class="para4"><span class="span3">Fortunately, the </span><span class="span8">i</span><span class="span3"> and </span><span class="span8">j</span><span class="span3"> variables start at zero, but </span><span class="span8">k</span><span class="span3"> has a starting value of 32766. In the numbers array, most elements also happen to start with zero, except the third element, which gets an initial value of 4199024.</span></p><p class="para4"><span class="span3">Compiling the same program on a different system further shows the danger in uninitialized variables. Don&apos;t assume &quot;all the world runs Linux&quot; because one day, your program might run on a different platform. For example, here&apos;s the same program running on FreeDOS:</span></p><p class="para6"><span class="span6">These variables are not initialized:</span></p><p class="para6"><span class="span6">  i = 0</span></p><p class="para6"><span class="span6">  j = 1074</span></p><p class="para6"><span class="span6">  k = 3120</span></p><p class="para6"><span class="span6">This array is not initialized:</span></p><p class="para6"><span class="span6">  numbers[0] = 3106</span></p><p class="para6"><span class="span6">  numbers[1] = 1224</span></p><p class="para6"><span class="span6">  numbers[2] = 784</span></p><p class="para6"><span class="span6">  numbers[3] = 2926</span></p><p class="para6"><span class="span6">  numbers[4] = 1224</span></p><p class="para6"><span class="span6">malloc an array ...</span></p><p class="para6"><span class="span6">This malloc&apos;ed array is not initialized:</span></p><p class="para6"><span class="span6">  array[0] = 3136</span></p><p class="para6"><span class="span6">  array[1] = 3136</span></p><p class="para6"><span class="span6">  array[2] = 14499</span></p><p class="para6"><span class="span6">  array[3] = -5886</span></p><p class="para6"><span class="span6">  array[4] = 219</span></p><p class="para7"><span class="span6">Ok</span></p><p class="para4"><span class="span3">Always initialize your program&apos;s variables. If you assume a variable will start with a zero value, add the extra code to assign zero to the variable. This extra bit of typing upfront will save you headaches and debugging later on.</span></p><p class="para5"><span class="span5">2. Going outside of array bounds</span></p><p class="para4"><span class="span3">In C, arrays start at array index zero. That means an array that is ten elements long goes from 0 to 9, or an array that is a thousand elements long goes from 0 to 999.</span></p><p class="para4"><span class="span3">Some programmers sometimes forget this and introduce &quot;off by one&quot; bugs where they reference the array starting at one. In an array that is five elements long, the value the programmer intended to find at array element &quot;5&quot; is not actually the fifth element of the array. Instead, it is some other value in memory, not associated with the array at all.</span></p><p class="para4"><span class="span3">Here&apos;s an example that goes well outside the array bounds. The program starts with an array that&apos;s only five elements long but references array elements from outside that range:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;stdlib.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int i;</span></p><p class="para6"><span class="span6">  int numbers[5];</span></p><p class="para6"><span class="span6">  int *array;</span></p><p class="para6"><span class="span6">  /* test 1 */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;This array has five elements (0 to 4)&quot;);</span></p><p class="para6"><span class="span6">  /* initalize the array */</span></p><p class="para6"><span class="span6">  for (i = 0; i &lt; 5; i++) {</span></p><p class="para6"><span class="span6">    numbers[i] = i;</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* oops, this goes beyond the array bounds: */</span></p><p class="para6"><span class="span6">  for (i = 0; i &lt; 10; i++) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  numbers[%d] = %d\n&quot;, i, numbers[i]);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* test 2 */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;malloc an array ...&quot;);</span></p><p class="para6"><span class="span6">  array = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="span7">malloc</span></a><span class="span6">(sizeof(int) * 5);</span></p><p class="para6"><span class="span6">  if (array) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;This malloc&apos;ed array also has five elements (0 to 4)&quot;);</span></p><p class="para6"><span class="span6">    /* initalize the array */</span></p><p class="para6"><span class="span6">    for (i = 0; i &lt; 5; i++) {</span></p><p class="para6"><span class="span6">      array[i] = i;</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">    /* oops, this goes beyond the array bounds: */</span></p><p class="para6"><span class="span6">    for (i = 0; i &lt; 10; i++) {</span></p><p class="para6"><span class="span6">      </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;  array[%d] = %d\n&quot;, i, array[i]);</span></p><p class="para6"><span class="span6">    }</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="span7">free</span></a><span class="span6">(array);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Ok&quot;);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Note that the program initializes all the values of the array, from 0 to 4, but then tries to read 0 to 9 instead of 0 to 4. The first five values are correct, but after that you don’t know what the values will be:</span></p><p class="para6"><span class="span6">This array has five elements (0 to 4)</span></p><p class="para6"> </p><p class="para6"><span class="span6">  numbers[0] = 0</span></p><p class="para6"><span class="span6">  numbers[1] = 1</span></p><p class="para6"><span class="span6">  numbers[2] = 2</span></p><p class="para6"><span class="span6">  numbers[3] = 3</span></p><p class="para6"><span class="span6">  numbers[4] = 4</span></p><p class="para6"><span class="span6">  numbers[5] = 0</span></p><p class="para6"><span class="span6">  numbers[6] = 4198512</span></p><p class="para6"><span class="span6">  numbers[7] = 0</span></p><p class="para6"><span class="span6">  numbers[8] = 1326609712</span></p><p class="para6"><span class="span6">  numbers[9] = 32764</span></p><p class="para6"><span class="span6">malloc an array ...</span></p><p class="para6"><span class="span6">This malloc&apos;ed array also has five elements (0 to 4)</span></p><p class="para6"><span class="span6">  array[0] = 0</span></p><p class="para6"><span class="span6">  array[1] = 1</span></p><p class="para6"><span class="span6">  array[2] = 2</span></p><p class="para6"><span class="span6">  array[3] = 3</span></p><p class="para6"><span class="span6">  array[4] = 4</span></p><p class="para6"><span class="span6">  array[5] = 0</span></p><p class="para6"><span class="span6">  array[6] = 133441</span></p><p class="para6"><span class="span6">  array[7] = 0</span></p><p class="para6"><span class="span6">  array[8] = 0</span></p><p class="para6"><span class="span6">  array[9] = 0</span></p><p class="para7"><span class="span6">Ok</span></p><p class="para4"><span class="span3">When referencing arrays, always keep track of its size. Store that in a variable; don&apos;t hard-code an array size. Otherwise, your program might stray outside the array bounds when you later update it to use a different array size, but you forget to change the hard-coded array length.</span></p><p class="para5"><span class="span5">3. Overflowing a string</span></p><p class="para4"><span class="span3">Strings are just arrays of a different kind. In the C programming language, a string is an array of </span><span class="span8">char</span><span class="span3"> values, with a zero character to indicate the end of the string.</span></p><p class="para4"><span class="span3">And so, like arrays, you need to avoid going outside the range of the string. This is sometimes called </span><span class="span9">overflowing a string</span><span class="span3">.</span></p><p class="para4"><span class="span3">One easy way to overflow a string is to read data with the </span><span class="span8">gets</span><span class="span3"> function. The </span><span class="span8">gets</span><span class="span3"> function is very dangerous because it doesn&apos;t know how much data it can store in a string, and it naively reads data from the user. This is fine if your user enters short strings like </span><span class="span8">foo</span><span class="span3"> but can be disastrous when the user enters a value that is too long for your string value.</span></p><p class="para4"><span class="span3">Here&apos;s a sample program that reads a city name using the </span><span class="span8">gets</span><span class="span3"> function. In this program, I&apos;ve also added a few unused variables to show how string overflow can affect other data:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;string.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  char name[10];                       /* Such as &quot;Chicago&quot; */</span></p><p class="para6"><span class="span6">  int var1 = 1, var2 = 2;</span></p><p class="para6"><span class="span6">  /* show initial values */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;var1 = %d; var2 = %d\n&quot;, var1, var2);</span></p><p class="para6"><span class="span6">  /* this is bad .. please don&apos;t use gets */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Where do you live?&quot;);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/gets.html"><span class="span7">gets</span></a><span class="span6">(name);</span></p><p class="para6"><span class="span6">  /* show ending values */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;&lt;%s&gt; is length %d\n&quot;, name, </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="span7">strlen</span></a><span class="span6">(name));</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;var1 = %d; var2 = %d\n&quot;, var1, var2);</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Ok&quot;);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">That program works fine when you test for similarly short city names, like </span><span class="span8">Chicago</span><span class="span3"> in Illinois or </span><span class="span8">Raleigh</span><span class="span3"> in North Carolina:</span></p><p class="para6"><span class="span6">var1 = 1; var2 = 2</span></p><p class="para6"><span class="span6">Where do you live?</span></p><p class="para6"><span class="span6">Raleigh</span></p><p class="para6"><span class="span6">&lt;Raleigh&gt; is length 7</span></p><p class="para6"><span class="span6">var1 = 1; var2 = 2</span></p><p class="para7"><span class="span6">Ok</span></p><p class="para4"><span class="span3">The Welsh town of </span><span class="span8">Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch</span><span class="span3"> has one of the longest names in the world. At 58 characters, this string goes well beyond the 10 characters reserved in the </span><span class="span8">name</span><span class="span3"> variable. As a result, the program stores values in other areas of memory, including the values of </span><span class="span8">var1</span><span class="span3"> and </span><span class="span8">var2</span><span class="span3">:</span></p><p class="para6"><span class="span6">var1 = 1; var2 = 2</span></p><p class="para6"><span class="span6">Where do you live?</span></p><p class="para6"><span class="span6">Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch</span></p><p class="para6"><span class="span6">&lt;Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch&gt; is length 58</span></p><p class="para6"><span class="span6">var1 = 2036821625; var2 = 2003266668</span></p><p class="para6"><span class="span6">Ok</span></p><p class="para7"><span class="span6">Segmentation fault (core dumped)</span></p><p class="para4"><span class="span3">Before aborting, the program used the long string to overwrite other parts of memory. Note that </span><span class="span8">var1</span><span class="span3"> and </span><span class="span8">var2</span><span class="span3"> no longer have their starting values of </span><span class="span8">1</span><span class="span3"> and </span><span class="span8">2</span><span class="span3">.</span></p><p class="para4"><span class="span3">Avoid </span><span class="span8">gets</span><span class="span3">, and use safer methods to read user data. For example, the </span><span class="span8">getline</span><span class="span3"> function will allocate enough memory to store user input, so the user cannot accidentally overflow the string by entering a long value.</span></p><p class="para5"><span class="span5">4. Freeing memory twice</span></p><p class="para4"><span class="span3">One of the rules of good C programming is, &quot;if you allocate memory, you should free it.&quot; Programs can allocate memory for arrays and strings using the </span><span class="span8">malloc</span><span class="span3"> function, which reserves a block of memory and returns a pointer to the starting address in memory. Later, the program can release the memory using the </span><span class="span8">free</span><span class="span3"> function, which uses the pointer to mark the memory as unused.</span></p><p class="para4"><span class="span3">However, you should only use the </span><span class="span8">free</span><span class="span3"> function once. Calling </span><span class="span8">free</span><span class="span3"> a second time will result in unexpected behavior that will probably break your program. Here&apos;s a short example program to show that. It allocates memory, then immediately releases it. But like a forgetful-but-methodical programmer, I also freed the memory at the end of the program, resulting in freeing the same memory twice:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">#include &lt;stdlib.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  int *array;</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;malloc an array ...&quot;);</span></p><p class="para6"><span class="span6">  array = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="span7">malloc</span></a><span class="span6">(sizeof(int) * 5);</span></p><p class="para6"><span class="span6">  if (array) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;malloc succeeded&quot;);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Free the array...&quot;);</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="span7">free</span></a><span class="span6">(array);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Free the array...&quot;);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="span7">free</span></a><span class="span6">(array);</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Ok&quot;);</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">Running this program causes a dramatic failure on the second use of the </span><span class="span8">free</span><span class="span3"> function:</span></p><p class="para6"><span class="span6">malloc an array ...</span></p><p class="para6"><span class="span6">malloc succeeded</span></p><p class="para6"><span class="span6">Free the array...</span></p><p class="para6"><span class="span6">Free the array...</span></p><p class="para6"><span class="span6">free(): double free detected in tcache 2</span></p><p class="para7"><span class="span6">Aborted (core dumped)</span></p><p class="para4"><span class="span3">Avoid calling </span><span class="span8">free</span><span class="span3"> more than once on an array or string. One way to avoid freeing memory twice is to locate the </span><span class="span8">malloc</span><span class="span3"> and </span><span class="span8">free</span><span class="span3"> functions in the same function.</span></p><p class="para4"><span class="span3">For example, a solitaire program might allocate memory for a deck of cards in the main function, then use that deck in other functions to play the game. Free the memory in the main function, rather than some other function. Keeping the </span><span class="span8">malloc</span><span class="span3"> and </span><span class="span8">free</span><span class="span3"> statements together helps to avoid freeing memory more than once.</span></p><p class="para5"><span class="span5">5. Using invalid file pointers</span></p><p class="para4"><span class="span3">Files are a handy way to store data. For example, you might store configuration data for your program in a file called </span><span class="span8">config.dat</span><span class="span3">. The Bash shell reads its initial script from </span><span class="span8">.bash_profile</span><span class="span3"> in the user&apos;s home directory. The GNU Emacs editor looks for the file </span><span class="span8">.emacs</span><span class="span3"> for its starting values. And the Zoom meeting client uses the </span><span class="span8">zoomus.conf</span><span class="span3"> file to read its program configuration.</span></p><p class="para4"><span class="span3">So the ability to read data from a file is important for pretty much all programs. But what if the file you want to read isn&apos;t there?</span></p><p class="para4"><span class="span3">To read a file in C, you first open the file using the </span><span class="span8">fopen</span><span class="span3"> function, which returns a stream pointer to the file. You can use this pointer with other functions to read data, such as </span><span class="span8">fgetc</span><span class="span3"> to read the file one character at a time.</span></p><p class="para4"><span class="span3">If the file you want to read isn&apos;t there or isn&apos;t readable by your program, then the </span><span class="span8">fopen</span><span class="span3"> function will return </span><span class="span8">NULL</span><span class="span3"> as the file pointer, which is an indication the file pointer is invalid. But here&apos;s a sample program that innocently does not check if </span><span class="span8">fopen</span><span class="span3"> returned </span><span class="span8">NULL</span><span class="span3"> and tries to read the file regardless:</span></p><p class="para6"><span class="span6">#include &lt;stdio.h&gt;</span></p><p class="para6"><span class="span6">int</span></p><p class="para6"><span class="span6">main()</span></p><p class="para6"><span class="span6">{</span></p><p class="para6"><span class="span6">  FILE *pfile;</span></p><p class="para6"><span class="span6">  int ch;</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Open the FILE.TXT file ...&quot;);</span></p><p class="para6"><span class="span6">  pfile = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fopen.html"><span class="span7">fopen</span></a><span class="span6">(&quot;FILE.TXT&quot;, &quot;r&quot;);</span></p><p class="para6"><span class="span6">  /* you should check if the file pointer is valid, but we skipped that */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Now display the contents of FILE.TXT ...&quot;);</span></p><p class="para6"><span class="span6">  while ((ch = </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fgetc.html"><span class="span7">fgetc</span></a><span class="span6">(pfile)) != EOF) {</span></p><p class="para6"><span class="span6">    </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="span7">printf</span></a><span class="span6">(&quot;&lt;%c&gt;&quot;, ch);</span></p><p class="para6"><span class="span6">  }</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/fclose.html"><span class="span7">fclose</span></a><span class="span6">(pfile);</span></p><p class="para6"><span class="span6">  /* done */</span></p><p class="para6"><span class="span6">  </span><a href="http://www.opengroup.org/onlinepubs/009695399/functions/puts.html"><span class="span7">puts</span></a><span class="span6">(&quot;Ok&quot;);</span></p><p class="para6"><span class="span6">  return 0;</span></p><p class="para7"><span class="span6">}</span></p><p class="para4"><span class="span3">When you run this program, the first call to </span><span class="span8">fgetc</span><span class="span3"> results in a spectacular failure, and the program immediately aborts:</span></p><p class="para6"><span class="span6">Open the FILE.TXT file ...</span></p><p class="para6"><span class="span6">Now display the contents of FILE.TXT ...</span></p><p class="para7"><span class="span6">Segmentation fault (core dumped)</span></p><p class="para4"><span class="span3">Always check the file pointer to ensure it&apos;s valid. For example, after calling </span><span class="span8">fopen</span><span class="span3"> to open a file, check the pointer&apos;s value with something like </span><span class="span8">if (pfile != NULL)</span><span class="span3"> to ensure that the pointer is something you can use.</span></p><p class="para4"><span class="span3">We all make mistakes, and programming bugs happen to the best of programmers. But if you follow these guidelines and add a little extra code to check for these five types of bugs, you can avoid the most serious C programming mistakes. A few lines of code up front to catch these errors may save you hours of debugging later.</span></p><p class="para4"> </p></body></html>